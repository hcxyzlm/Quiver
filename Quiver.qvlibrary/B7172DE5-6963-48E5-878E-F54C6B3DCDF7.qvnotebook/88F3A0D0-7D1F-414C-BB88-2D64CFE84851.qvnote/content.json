{
  "title": "Clang初识",
  "cells": [
    {
      "type": "markdown",
      "data": "参考文章：[LLVM论述](http://www.aosabook.org/en/llvm.html)，[clang-plugin-with-xcode](https://railsware.com/blog/creation-and-using-clang-plugin-with-xcode/)\n简介：\nXcode中我们最常使用的一个组合键`cmd+b`按下之后都进行了哪一些工作？\n\n## Clang\n我们知道 XCode 的编译器是用LLVM(xcode 5.0之前是 gcc)，而Clang 是为LLVM的子项，支持C、C++、Objective-C和Objective-C++，作用为 LLVM，它采用了底层虚拟机（LLVM）作为其后端。有数据表明，他的编译OC 的代码速度是 gcc 的三倍\n\n## LLDB\n我们知道GCC编译GDB的debug 诊断工具，LLDB的就是Clang的Debug工具。LLDB和GDB很多命令都是类似的，比如 PO命令\n\n### LLVM和Clang 的关系\n![IMAGE](quiver-image-url/13777D97E5CCCE3823CA3ED98AD6495D.jpg =623x422)\n\n\n### 架构图\n![IMAGE](quiver-image-url/18BFA8AEA16EDD439C9DBF5248598813.jpg =1356x811)\n\nPS: Swfit Frontend 中还包含一层 SIL 及Optimizer,先做了一层优化的中间层\n\n\n### xcode 编译流程\n![IMAGE](quiver-image-url/4C6034E07018875952A56911B4011B2B.jpg =1124x884)\n相当于xcode把所有的文件执行了的一段脚本\n\n当我们按下 Run 之后\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x objective-c ... -o main.o\n\n## 编译过程\n\n### demo\n\n```objc\nmain.m\n#import <Foundation/Foundation.h>\n\nint main(){\n    @autoreleasepool {\n        NSObject *obj = [[NSObject alloc] init];\n        NSLog(\"hello, world, %@\", obj);\n    }\n    return 0;\n}\n```\n预处理（Pre-process）\n  - import 头文件\n  - 宏展开\n  - 处理'#'打头的预处理指令，如#if\n  - 生成i 文件\n  \n### 命令： clang -E main.m\n\n```\n...\n...\n# 1 \"/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk/System/Library/Frameworks/Foundation.framework/Headers/FoundationLegacySwiftCompatibility.h\" 1 3\n# 185 \"/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h\" 2 3\n# 2 \"main.m\" 2\n\nint main(){\n    @autoreleasepool {\n        NSObject *obj = [[NSObject alloc] init];\n        NSLog(\"hello, world, %@\", obj);\n    }\n    return 0;\n}\n```\n\n### 语法分析\n  - 词法分析，也叫做Tokenization\n  - 将预处理的代码文本转化成 token 流\n  - 不校验语义\n  \n### 命令：clang -fmodules -fsyntax-only -Xclang -dump-tokens  main.m\n```\nannot_module_include '#import <F'\t\tLoc=<main.m:1:1>\nint 'int'\t [StartOfLine]\tLoc=<main.m:3:1>\nidentifier 'main'\t [LeadingSpace]\tLoc=<main.m:3:5>\nl_paren '('\t\tLoc=<main.m:3:9>\nr_paren ')'\t\tLoc=<main.m:3:10>\nl_brace '{'\t\tLoc=<main.m:3:11>\nat '@'\t [StartOfLine] [LeadingSpace]\tLoc=<main.m:4:5>\nidentifier 'autoreleasepool'\t\tLoc=<main.m:4:6>\nl_brace '{'\t [LeadingSpace]\tLoc=<main.m:4:22>\nidentifier 'NSObject'\t [StartOfLine] [LeadingSpace]\tLoc=<main.m:5:9>\nstar '*'\t [LeadingSpace]\tLoc=<main.m:5:18>\nidentifier 'obj'\t\tLoc=<main.m:5:19>\nequal '='\t [LeadingSpace]\tLoc=<main.m:5:23>\nl_square '['\t [LeadingSpace]\tLoc=<main.m:5:25>\nl_square '['\t\tLoc=<main.m:5:26>\nidentifier 'NSObject'\t\tLoc=<main.m:5:27>\nidentifier 'alloc'\t [LeadingSpace]\tLoc=<main.m:5:36>\nr_square ']'\t\tLoc=<main.m:5:41>\nidentifier 'init'\t [LeadingSpace]\tLoc=<main.m:5:43>\nr_square ']'\t\tLoc=<main.m:5:47>\nsemi ';'\t\tLoc=<main.m:5:48>\nidentifier 'NSLog'\t [StartOfLine] [LeadingSpace]\tLoc=<main.m:6:9>\nl_paren '('\t\tLoc=<main.m:6:14>\nat '@'\t\tLoc=<main.m:6:15>\nstring_literal '\"hello, world, %@\"'\t\tLoc=<main.m:6:16>\ncomma ','\t\tLoc=<main.m:6:34>\nidentifier 'obj'\t [LeadingSpace]\tLoc=<main.m:6:36>\nr_paren ')'\t\tLoc=<main.m:6:39>\nsemi ';'\t\tLoc=<main.m:6:40>\nr_brace '}'\t [StartOfLine] [LeadingSpace]\tLoc=<main.m:7:5>\nreturn 'return'\t [StartOfLine] [LeadingSpace]\tLoc=<main.m:8:5>\nnumeric_constant '0'\t [LeadingSpace]\tLoc=<main.m:8:12>\nsemi ';'\t\tLoc=<main.m:8:13>\nr_brace '}'\t [StartOfLine]\tLoc=<main.m:9:1>\neof ''\t\tLoc=<main.m:9:2>\n```\n\n### 语法分析\n- 语法分析，在Clang 中由Parser 和Sema两个模块配合完成\n- 验证语法是否正确![IMAGE](quiver-image-url/4ED878F8E3F4CA926B98806620F010B3.jpg =619x80)\n- **根据当前语法，生成任意节点，将所有节点组合成抽象语法树**\n\n![IMAGE](quiver-image-url/24B3CC2316019D4342E8E05320F8D681.jpg =1319x786)\n\n### 静态分析\n- 通过语法树进行代码静态分析，找出非语法性错误\n- 预设了常用的 chcker\n![IMAGE](quiver-image-url/64C8D0D2BF45CCE5732B98A600CE4AEA.jpg =321x113)\n\n### CodeGen -IR代码生成\n- CodeGen 负责将语法树从上至下遍历，翻译成LLVM-IR\n- LLVM-IR 是 Frontend 的输出，也是 LLVM backend的输入，是前后端的桥接语言\n- ** 与 Object-C Runtime 桥接\n\n### 与 Object-C Runtime 桥接\n- Class/meta class /protocol/ category内存代码生成\n- 比如：将语法中的发送消息翻译成 objc_msgSend， 对 supr 关键字的调用翻译成 objc_msgSendSuper。\n- 根据修饰符strong/weak/assgin合成@property的 set/getter\n- block 的生成\n- 处理@syntheszie\n\n**命令：clang -S -fobjc-arc -emit-llvm main.m -o main.ll**\n\n```\ndefine i32 @main() #0 {\n  %1 = alloca i32, align 4\n  %2 = alloca %0*, align 8\n  store i32 0, i32* %1, align 4\n  %3 = call i8* @objc_autoreleasePoolPush() #3\n  %4 = load %struct._class_t*, %struct._class_t** @\"OBJC_CLASSLIST_REFERENCES_$_\", align 8\n  %5 = load i8*, i8** @OBJC_SELECTOR_REFERENCES_, align 8, !invariant.load !9\n  %6 = bitcast %struct._class_t* %4 to i8*\n  %7 = call i8* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to i8* (i8*, i8*)*)(i8* %6, i8* %5)\n  %8 = bitcast i8* %7 to %0*\n  %9 = load i8*, i8** @OBJC_SELECTOR_REFERENCES_.2, align 8, !invariant.load !9\n  %10 = bitcast %0* %8 to i8*\n  %11 = call i8* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to i8* (i8*, i8*)*)(i8* %10, i8* %9)\n  %12 = bitcast i8* %11 to %0*\n  store %0* %12, %0** %2, align 8\n  %13 = load %0*, %0** %2, align 8\n  notail call void (i8*, ...) @NSLog(i8* bitcast (%struct.__NSConstantString_tag* @_unnamed_cfstring_ to i8*), %0* %13)\n  %14 = bitcast %0** %2 to i8**\n  call void @objc_storeStrong(i8** %14, i8* null) #3\n  call void @objc_autoreleasePoolPop(i8* %3)\n  ret i32 0\n}\n\ndeclare i8* @objc_autoreleasePoolPush()\n```\n\n### 优化 IR\n\n### bitcode -生成字节码\n**clang -emit-llvm -c main.m -o main.bc**\n![IMAGE](quiver-image-url/62DACDADF68B8D13A2FC3F4CCDAF9BA1.jpg =489x669)\n\n### 生成Target 相关 汇编\n**clang -S -fobjc-arc main.m -o main.s**\n![IMAGE](quiver-image-url/7170E53F2DD17DCC969EBCAD46F18168.jpg =816x535)\n\n### 生成 target 相关的 object(mach-o)\n![IMAGE](quiver-image-url/98B4B2EFBB0E7FB25B8BB0D4C50342C7.jpg =900x422)\n\n### 链接生成可执行文件\nclang -fmodules main.m -o main\n\n##编译过程总结\n- clang-llvm 下，一个源文件的编译过程\n- ![IMAGE](quiver-image-url/3F7DB2B7F0820DA6D121DA9D90A0DB4F.jpg =1037x543)\n\n### Clang 能做什么？\n- libClang\n- libTooling\n- ClangPlugin\n\n#### libClang\n- 使用C-API，来访问上层能力，比如获取Tokens, 遍历语法树，代码补全，获取诊断信息\n- 使用官方提供的python/ruby/node-js 开发\n- 开源库[ClangKit](https://xs-labs.com/en/projects/clang-kit/overview/)\n\n#### LibTooling\n- 对语法树有完全的控制权\n- 语法：c++,并且很熟悉clang的源码\n\n#### ClangPlugin\n- 对语法树有完全的控制权\n- 可以作为插件集成到 xcode 中，影响 bulid和决定编译过程\n- 语法要求：c++,并且很熟悉clang的源码\n\n\n### 实战 demo\n####  下载 clang源码\n\n```objc\ngit clone -b release_60 git@github.com:llvm-mirror/llvm.git llvm\ngit clone -b release_60 git@github.com:llvm-mirror/clang.git llvm/tools/clang\ngit clone -b release_60 git@github.com:llvm-mirror/clang-tools-extra.git llvm/tools/clang/tools/extra\ngit clone -b release_60 git@github.com:llvm-mirror/compiler-rt.git llvm/projects/compiler-rt\n```\n### 编译源码\n\n```objc\nmkdir llvm_build; cd llvm_build\ncmake -G Xcode ../llvm -DCMAKE_BUILD_TYPE:STRING=MinSizeRel\n```\n打开LLVM.xcodeproj,编译clang 和 libClang\n2.编写 c++代码\n```objc\nbool VisitObjCInterfaceDecl(ObjCInterfaceDecl *declaration)\n        {\n            printf(\"#########插件检查前########\\n\");\n            const clang::SourceManager &sm = context->getSourceManager();\n            clang::FullSourceLoc loc = context->getFullLoc(declaration->getLocStart());\n            if (!sm.isInSystemHeader(loc)) {\n                string name = declaration->getName();\n                if (std::islower(name[0]) || std::islower(name[1])) {\n                    \n                    /// 报告弹框\n                    DiagnosticsEngine &D =  context->getDiagnostics();\n                    int diagID = D.getCustomDiagID(DiagnosticsEngine::Warning, \"缺少object-c 类前缀\");\n                    D.Report(loc.getLocWithOffset(11), diagID);\n                }\n            }\n            printf(\"#########插件检查后########\\n\");\n            return true;\n        }\n```\n\n3. 新建一个新的工程，工程配置如下：\n添加用户自定义设置：CC, 变量为：/opt/llvm/llvm_build/Debug/bin/clang\n![IMAGE](quiver-image-url/57CD1E0B00B5F8F7A1AF39B01C6B6FAE.jpg =980x713)\nother c flag\n![IMAGE](quiver-image-url/351B88361A207419A681ED739CB8020C.jpg =974x712)\n-Xclang -load -Xclang /Users/zhuo/Clang_Compiler/MyPlugin.dylib -Xclang -add-plugin -Xclang MyPlugin\n-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator12.4.sdk\nindex\n![IMAGE](quiver-image-url/9B9D964DA3988C7BAC8946D558784BCE.jpg =987x227)\n\n### 命令行编译\n/opt/llvm/llvm_build/Debug/bin/clang -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator12.4.sdk -Xclang -load -Xclang ./MyPlugin.dylib -Xclang -add-plugin -Xclang MyPlugin -c ./AppDelegate.m\n![IMAGE](quiver-image-url/3F98869C7F8C9C05226DB10D923903A5.jpg =901x169)\n\n### 问题： \n1. 编译器可以编程程序，编译器本身也是一个程序，那他一定是由更早的编译器编译而来，问，最早的编译器是哪里来的？\n2. 能利用 clang 做什么？足迹埋点，CI 集成。。。。\n\n\n\n\n\n\n"
    },
    {
      "type": "text",
      "data": "<br>"
    },
    {
      "type": "text",
      "data": ""
    }
  ]
}