{
  "title": "网络安全之密码学",
  "cells": [
    {
      "type": "markdown",
      "data": "## 密码学\n### 在网络开发的时候，有两个原则\n1. 不允许明文发送用户的隐私信息\n2. 不允许明文保存用户的隐私信息\n\n### 加密算法\n1. 哈希(散列)算法 : \n  - md5\n  - sha1\n  - sha512\n2. 对称\n3. 非对称\n\n### md5\n特点\n1.哥们不能逆回\n2.同样的数据结加密后数据是一样的，有网路可以破解，不安全\n3.（ios commoncrypto.h 文件有md5加密），生成32位字符串，服务器不需要知道用户的密码，用于用户的密码加密\n4.解决: 加盐， 数据 = (密码 + 盐).md5\n5.HMAC，最近比较火，自爱国内比较火。给定了一个\"密钥\"，对明文进行加密，再进行两次散列，其实也是加盐(这个key从服务器获取的.一个账号对应一个key)\n![19A2E201-402F-411A-A08B-B7C776157211.png](quiver-image-url/3C41304E6A37B2F11A4458D1ECAD59E1.png)\n6. 这种算法也不安全，黑客也可以模拟欺骗服务器，可以登上用户app，客户端可以有权限可以服务器的东西，做破坏。\n7. 解决方案: 每次登陆请求的数据都不一样，加上时间戳。![34D283FB-09BD-41DD-9495-8F4A1F392F9B.png](quiver-image-url/0D39832125A2FB33FFC0BD5499E8850C.png)\n作用: \n搜索: 百度的搜索是一样的\nios hank 长沙 | 长沙 hank ios 百度结果是一样的，怎么做到的\n      ios.md5\n      长沙.md5\n      hank.md5\n      三个32位的结果按位相加，得到的结果是一样的，不管你怎么排序。\n版权:\n    原板md5 1234\n    盗版md5 4321\n\n###  对称加密(可逆运算)\n    也需要一个key(密钥加密。然后密钥解密)\n-- DES\n-- 3EDs\n-- AES(现在的计算速度，破解需要大概5000万年)AES加密算法，高级密码标准，美国国防安全使用的。对称加密算法\n\n### RSA 非对称(持续到上个世纪70年代，出现的伟大加密算法)\n## 领域 -- 军事\n1. 密钥加密，公钥加密\n2. 公钥加密，密钥解密\n\n\n### 钥匙串访问(SSKeyChain)\n1. 苹果的生态圈,从ios 7开放了钥匙串访问功能。\n2. 将用户的密码用AES加密之后保存。\n3. 保存一个密码是三个参数完成的:1. 你的app唯一标示 2.你的账号 3. 你的密码\n4. 去密码两个参数搞定:1. 你的app唯一标示 2.你的账号\n\n密码学是高级程序员的话题\n\n## 对称加密\n-- 加密和解密都是使用同一个“密钥”\n-- 密钥的保密工作非常重要。密钥会定期进行更换\n\n经典的加密算法\nDES   数据加密标准(用的少，因为强度不够)\n3DES  使用三个密钥，对相同的数据进行三次加密，强度增强\nAES   高级密码标准\n\n\n加密方式\nEBC： 电子代码本，就是没一块都进行一次独立的加密\nCBC:  密码块\"链\"，使用一个密钥和初始化向量(IV)对数据执行加密转换，下一块加密需要依赖上一块加密。\n\n\n苹果要求，所有的网络请求，都有一个单例负责的。那么既然是单例，vc不被释放也没有关系。\n\n## 加密算法和协议\n1. 对称加密\n      加密和解密都使用同一个密钥，将数据分隔成固定大小的快，逐快加密；且块与块之间有关联关系\n      算法:DES,3DES,AES,Blowfish,Twofish,IDEA,RC6,CAST5\n      缺陷: 密钥过多；密钥分发成为难题；\n2. 公钥加密\n      密钥分为公钥和私钥\n      公钥: 从私钥中提取产生，可公开给所有人；publickKey\n      私钥: 通过工具创建，使用者自己保留，必须保证其私密性，secret key.\n用公钥加密的数据，只能用之配对的私钥加密，私钥加密的数据，只能用之配对的私钥解密\n用途:\n    1. 数字签名:确认发送者的身份\n    2. 密钥交换:发送方用对方的公钥加密一个对称密钥，并发送给对方\n    3. 算法: RSA，DSA,ELGamal\n3.单向加密：\n      提取数据指纹；只能加密，不能解密；\n      定长输出；雪崩效应\n      作用：数据完整性验证；\n      算法：md5(128bits),sha1(160bits),sha224,sha256,sha384,sha512\n\n4. 密钥交换\n    1.公钥加密\n    2.DH算法()\n\n\n## openssl命令加密解密\n1. 对称加密\n```objc\n加密：openssl enc -e -des3 -a -salt -in /path/from/somefile -out\n/path/to/somefile\n。解密：openssl enc -d -des3 -a -salt -out /path/to/somefile -in /path/to/somefile\n```\n\n## https的原理\n  相当于htpp + ssl,在http通信接口部分用ssl 和tls协议代替。\n  https的加密方法:相互交换密钥的公开密钥加密方式\n  共享密钥：服务器和客户端都用相同的来加密解密\n  公开密钥： 非对称的加密方法，公钥加密，私钥解密\n  http使用非对称的方式发送密钥，确保了密钥的安全性，通信加密选择了用共享密钥的方式来加密解密\n\n## 指纹支付\n    LAContext\n```objc\n- (BOOL)canEvaluatePolicy:(LAPolicy)policy error:(NSError * _Nullable *)error\n  检测指纹可以用\n  \n  - (void)evaluatePolicy:(LAPolicy)policy localizedReason:(NSString *)localizedReason reply:(void (^)(BOOL success, NSError *error))reply\n  // 验证支付\n  1. 参数 1.LAPolicy 需要新建\n  2.localizedReason 指纹识别的标题\n```\n\n```objc\n/**\n *  指纹识别\n */\n- (void)laContext {\n    LAContext * lac = [[LAContext alloc]init];\n    \n    //判断设置是否支持指纹识别\n    NSError * error = nil;\n    if ([lac canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&error]) {\n        //输入指纹\n        [lac evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:@\"请按下你的脚趾头\" reply:^(BOOL success, NSError * _Nullable error) {\n            if (!error) {\n                NSLog(@\"%d扣钱成功!!!\",success);\n            }else{\n                NSLog(@\"%@%d\",error,success);\n            }\n        }];\n        \n        \n    }else{\n        NSLog(@\"%@\",error);\n    }\n    \n}\n\n\n```\n"
    },
    {
      "type": "text",
      "data": "<br>"
    }
  ]
}