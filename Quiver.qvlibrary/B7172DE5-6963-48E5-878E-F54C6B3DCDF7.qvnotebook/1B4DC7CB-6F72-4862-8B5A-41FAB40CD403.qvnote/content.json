{
  "title": "rxswift学习",
  "cells": [
    {
      "type": "markdown",
      "data": "### Observable(事件，序列)\n\n### Observable的类型\n  - empty, 空的序列，只有empty, completed\n  - just 只包含一个事件的序列\n  - of/from 包含固定个数事件的序列\n  - error 只产生.Error事件的序列\n  - create - 自定义的事件序列\n  - generate - 用prev决定next的事件序列，相当于循环\n  - deferred - 只有在被订阅后才创建并产生事件的序列\n  \n### 示例\n```swift\n        print(\"empty\")\n        let emptySequese =  Observable<Int>.empty()\n        emptySequese.subscribe { (event:RxSwift.Event<Int>) -> Void in\n            print(\"\\(event)\")\n        }\n        \n        // just,只包含一个事件的序列\n        print(\"just\")\n        _ = Observable<Int>.just(5).subscribe({ (event) in\n            print(event)\n        })\n        \n        // of 包含固定个数事件的序列\n        print(\"of\")\n        let ofSequese =  Observable<Int>.of(1, 2, 3, 4, 5, 6, 7, 8, 9)\n        ofSequese.subscribe { (event) in\n            print(event)\n        }\n        \n        // error 只产生.Error事件的序列\n        print(\"error\")\n        let error = NSError(domain: \"test\", code: -1, userInfo: nil)\n        _ = Observable<Int>.error(error).subscribe({ (event) in\n            print(event)\n        })\n        \n        \n        // create - 自定义的事件序列\n        print(\"create\")\n        func myJust(event: Int) -> Observable<Int> {\n            return Observable.create({ (observer) -> Disposable in\n                if event % 2 == 0 {\n                    observer.onNext(event)\n                    observer.onCompleted()\n                }else {\n                    let error = NSError(domain: \"not an event number\", code: -1, userInfo: nil)\n                    observer.on(.error(error))\n                }\n                \n                return Disposables.create()\n            })\n        }\n        \n        _ = myJust(event: 5).subscribe { (event) in\n            print(event)\n        }\n        \n        myJust(event: 10).subscribe { (event) in\n            print(event)\n        }\n        \n        // generate - 用prev决定next的事件序列，相当于循环\n        print(\"generate\")\n        _ = Observable.generate(initialState: 0, condition: { (number) -> Bool in\n            return number < 10\n        }, iterate: { (index) -> Int in\n           return index+1\n        }).subscribe({ (event) in\n            print(event)\n        })\n        \n        //deferred - 只有在被订阅后才创建并产生事件的序列\n        let deferredVable = Observable<Int>.deferred { () -> Observable<Int> in\n            print(\"deferred create\")\n            return Observable.generate(initialState: 0, condition: { (index) -> Bool in\n                return index < 3\n            }, iterate: { (index) -> Int in\n                return index+1\n            })\n        }\n        \n        deferredVable.subscribe { (event) in\n            print(event)\n        }\n        \n        deferredVable.subscribe { (event) in\n            print(event)\n        }\n```\n\n### 序列的时间类型\n  - next 事件\n  - error 事件\n  - completed 完成，一般序列完成会自动释放资源\n\n### DisposeBag 订阅者\n  - 序列的需要被订阅才会产生效应\n  - 使用subscribe订阅需要关心的事件\n  - 可以将订阅者置为nil，来回收事件的序列资源\n  - Disposable调用dispose来取消订阅\n  \n```swift\nObservable<Int>.interval(1, scheduler: MainScheduler.instance).subscribe(onNext:{\n            print(\"subscribe \\($0)\")\n        }) {\n            print(\"the queue was disposed \")\n        }.disposed(by: bag)\n        \n        delay(5) {\n            bag =    DisposeBag()\n            \n        }\n```\n\n### rxswift debug可以调试\n### 解决UITableViewCell跟UICollectionViewCell来说,cell在重用前释放掉之前被绑定的资源\n```objc\nclass TanTableViewCell: UITableViewCell { \nvar disposeBag: DisposeBag? \nvar viewModel: TanCellViewModel? { \ndidSet { \nlet disposeBag = DisposeBag() \nviewModel?.title \n.drive(self.textLabel!.rx_text) \n.addDisposableTo(disposeBag) \nself.disposeBag = disposeBag \n} \n} \noverride func prepareForReuse() { \nsuper.prepareForReuse() \nself.disposeBag = nil \n} \n} \n\n/// 监听\ncell.rankItemClicked.subscribe(onNext: { (rankItem) in\n                Router.push(publishType: .entityDetailPage, params: [RouteParamKey.Common.id: rankItem.id])\n            }).disposed(by: cell.dispose)\n```"
    }
  ]
}