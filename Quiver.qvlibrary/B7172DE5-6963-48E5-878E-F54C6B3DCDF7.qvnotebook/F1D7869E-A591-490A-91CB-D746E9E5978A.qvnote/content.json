{
  "title": "23种设计模式 swift 版",
  "cells": [
    {
      "type": "markdown",
      "data": "## 设计模式七大原则\n### 1. 单一职责原则\n- 一个类只负责一个功能领域中的相应职责\n### 2. 里氏替换原则\n- 任何基类可以出现的地方，子类一定可以出现\n### 3. 依赖倒置原则\n- 针对接口编程，依赖于抽象而不依赖于具体\n### 4. 接口隔离原则\n- 使用多个隔离的接口，比使用单个接口要好\n### 5. 迪米特法则(最少知识原则)\n- 一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。\n### 6. 合成复用原则\n- 尽量使用合成/聚合的方式，而不是使用继承。\n### 7.开闭原则\n- 对扩展开放，对修改关闭\n\n\n##23种设计模式\n## 创建型模式\n1. 单例模式（Singleton）\n定义：保证一个类只有一个实例，并提供一个访问它的全局访问点。\n    主要解决：一个全局使用的类频繁地创建与销毁。\n    使用场景：对于频繁使用的类，解决系统资源\n    如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。\n    关键代码：构造函数是私有的。\n``` swift\n  // final关键字的作用是这个类或方法不希望被继承和重写\nfinal class SingletonManager: NSObject {\n    //构造函数是私有的。\n    private override init(){}\n    static let shared = SingletonManager() // “懒实例化”的全局变量会被自动放在dispatch_once块中[4]\n    \n    func doSomeThing() {\n        print(\"\\(self) Current method --------- \\(#function)\")\n    }\n}\n// 方式二：在方法内定义静态常量\nfinal class SingletonManager2: NSObject {\n    //构造函数是私有的。\n    private override init(){}\n    \n    static var shared:SingletonManager2 {\n        struct Static {\n            static let instance : SingletonManager2 = SingletonManager2()\n        }\n        return Static.instance\n    }\n}\n```\n\n2. 工厂模式（Factory）\n定义：定义一个创建对象的接口，让其子类决定实例化哪一个工厂类，工厂方法使一个类实例化延迟到其子类进行。\n    主要解决：主要解决接口选择的问题。\n    何时使用：我们明确地计划不同条件下创建不同实例时。\n    如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。\n    关键代码：创建过程在其子类执行。\n\n3. 简单方法模式\n\n```swift\n/// 定义协议\nprotocol SimpleProduct {\n    func method1()\n}\n\nclass ConcreteProductA: SimpleProduct {\n    func method1() {\n        /// 业务代码\n    }\n}\nclass ConcreteProductB: SimpleProduct {\n    func method1() {\n        /// 业务代码\n    }\n}\n\n/// 简单工厂\nclass SimpleFactory {\n    func createProduct(type: Int) -> SimpleProduct {\n        if type == 0 {\n        /// 需要指定他们的实现类\n            return ConcreteProductA()\n        } else {\n            return ConcreteProductB()\n        }\n    }\n}\n```\n4. 抽象工厂模式\n\n定义：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。\n    主要解决：主要解决接口选择的问题。\n    何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。    \n    如何解决：在一个产品族里面，定义多个产品。    \n    关键代码：在一个工厂里聚合多个同类产品。    \n    应用实例：美业里面的打印机，可以划分为蓝牙，wifi，usb 连接类型的工厂方法。连接类型又有不同的品牌打印机，比如应美云，365打印机。\n    缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码\n  \n```swift\n    // 定义产品\n@objc protocol Product {\n    func print()\n}\n\n// 365\nclass Product_365: Product {\n    func print() {\n       /// 打印\n    }\n}\n\n// 具体产品2\nclass Product_YingMeiYun: Product {\n    func print() {\n        // 业务罗辑处理\n    }\n}\n\n// 工厂方法基类\nclass Factory {\n    var type: Int = 0\n    func createProduct() -> Product? { return nil } // 用于继承\n}\n\n// wifi 打印机类型\nclass WifiPrintFactory: Factory {\n    override func createProduct() -> Product? {\n        /// 应美云可用\n        if type == 0  {\n            return Product_YingMeiYun()\n        } else {\n            /// wifi365\n            return Product_365()\n        }\n    }\n}\n\n// 创建生产产品2的工厂类\nclass BluetoothPrint: Factory {\n    override func createProduct() -> Product? {\n        /// 找出可用\n        if type == 0  {\n            return Product_YingMeiYun()\n        } else {\n            return Product_365()\n        }\n    }\n}\n\nclass Client {\n    let f = Factory()\n}\n```\n\n5. 创建者模式/建造者模式（Builder）\n    定义：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。    \n        \n    如何解决：将变与不变分离开。    \n    关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。    \n    应用实例：构造一个方法可能会调用不同的组合，才会初始化一个类 \n    注意事项：\n        1、与工厂模式的区别是：建造者模式更加关注与方法装配的顺序。\n```swift\n// 产品\nclass BuilderProduct{\n    func method1() {\n        print(\"\\(self)\" + \"\\(#function)\")\n    }\n}\n\n// 建造者\nprotocol Builder {\n    func setPart()\n    func buildProduct() -> BuilderProduct\n}\n\n// 具体建造者\nclass ConcreteProductBp: Builder{\n    private var product = BuilderProduct()\n    // 设置产品零件\n    func setPart() {\n        // 处产品类内的罗辑处理\n        print(self)\n    }\n    \n    func buildProduct() -> BuilderProduct {\n        return product\n    }\n}\n\nclass Director {\n    private var builder = ConcreteProductBp()\n    func getAProduct() -> BuilderProduct {\n        builder.setPart()\n        // 设置不同的零件，产生不同的产品\n        return builder.buildProduct()\n    }\n}\n```\n6. 原型模式（Prototype）\n定义：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。    \n    主要解决：在运行期建立和删除原型。\n应用实例：深浅拷贝方法，json 序列化\n\n\n##结构型模式\n1. 适配器模式（Adapter）\n    定义：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\n    使用实例： \n        1、系统需要使用现有的类，而此类的接口不符合系统的需要。 \n        2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 \n        3、通过接口转换，将一个类插入另一个类系中。IGListKit，listbox 等都有使用\n    关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。 \n\n```swift\n// 目标角色\nprotocol Target {\n    // 目标角色自己的方法\n    func request()\n}\n\n// 源角色\nclass Adaptee {\n    // 原有的业务罗辑\n    func doSomeThing() {\n        print(\"原有的业务罗辑 thing\")\n    }\n}\n\n// 具体目标角色\nclass ConcreteTarget: Target {\n    func request() {\n        print(\"现有的业务 thing\")\n    }\n}\n\n// 适配器角色\nclass Adapter:Adaptee, Target {\n    \n    func request() {\n        super.doSomeThing()\n    }\n}\n```\n  \n2. 代理模式（Proxy）\n    定义：为其他对象提供一种代理以控制对这个对象的访问。    \n    如何解决：增加中间层。    \n    关键代码：实现与被代理类组合。    \n    应用实例： \n              TableViewDelegate, TableViewDataSource\n    优点：\n        1、职责清晰。 \n        2、高扩展性。 \n        3、智能化。    \n3. 装饰模式（Decorator）\n    定义：动态地给一个对象添加一些额外的职责。就增加功能来说，不需要生成子类，使用更为灵活。    \n    使用场景： \n        1、扩展一个类的功能。 \n        2、动态增加功能，动态撤销。    \n        oc,swift 中的分类用到该模式\n4. 桥梁模式/桥接模式（Bridge）\n    定义：将抽象部分与实现部分分离，使它们都可以独立的变化。\n    主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。\n    何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。    \n    如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。    \n    关键代码：抽象类依赖实现类。    \n    应用实例： 大部分的路由协议跳转，使用协议\n```swift\n  \n```\n\n5. 外观模式/门面模式（Facade门面模式）\n    定义：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。    \n    主要解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。    \n    何时使用： 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个\"接待员\"即可。 2、定义系统的入口。    \n    如何解决：客户端不与系统耦合，外观类与系统耦合。    \n    关键代码：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。    \n    应用实例： BillingFacade, ShopFacade等\n\n6。 组合模式（Composite）\n    定义：将对象组合成树形结构以表示\"部分-整体\"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。\n    主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。 \n    好处：\n    1、高层模块调用简单。 \n    2、节点自由增加。   \n    实例： 开单类的poser\n```swift\nclass BaseOrderComposer: BaseViewModel {\n    \n    var order = Order()\n    \n    private(set) lazy var util = OrderComposerUtil(order: order)\n    private(set) lazy var buyComposer = BuyerComposer(order: order)\n    private(set) lazy var promotionComposer = OrderPromotionComposer(order: order)\n    private(set) lazy var itemComposer = ItemComposer(order: order)\n    private(set) lazy var giftComposer = OrderGiftComposer(order: order)\n}\n```\n\n7. 享元模式（Flyweight）\n    定义：运用共享技术有效地支持大量细粒度的对象。    \n    主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。    \n    关键代码：用 dictory 存储这些对象。    \n    应用实例： HomePage的右侧实例缓存，当切换menu 的时，先返回缓存的种的实例对象，免费重新创建\n\n\n### 行为型模式\n1、模板方法模式（Template Method）\n    定义：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。    \n    主要解决：一些方法通用，却在每一个子类都重新写了这一方法。    \n    何时使用：有一些通用的方法。    \n    如何解决：将这些通用算法抽象出来。    \n    关键代码：在抽象类实现，其他步骤在子类实现。    \n    应用实例： \n            \n    优点： \n        1、封装不变部分，扩展可变部分。 \n        2、提取公共代码，便于维护。 \n        3、行为由父类控制，子类实现。\n    缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。    \n    使用场景： 1、有多个子类共有的方法，且逻辑相同。开单的匹配权益算法，耗卡的计算方法\n  \n    \n    \n  2. 观察者模式（Observer）\n    意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。    \n    主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。    \n    何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。    \n    如何解决：使用面向对象技术，可以将这种依赖关系弱化。    \n    关键代码：在抽象类里有一个 ArrayList 存放观察者们。    \n    应用实例：kvo, 通知等实现用到\n\n3. 状态模式（State）\n    定义：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。    \n    主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。    \n    何时使用：代码中包含大量与对象状态有关的条件语句。    \n    如何解决：将各种具体的状态类抽象出来。    \n    关键代码：通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if...else 等条件选择语句。    \n    应用实例：\n        1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 \n        2、曾侯乙编钟中，'钟是抽象接口','钟A'等是具体状态，'曾侯乙编钟'是具体环境（Context）。    \n    优点： \n        1、封装了转换规则。 \n        2、枚举可能的状态，在枚举状态之前需要确定状态种类。 \n        3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 \n        4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 \n        5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。\n\n    缺点： \n        1、状态模式的使用必然会增加系统类和对象的个数。\n        2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。\n        3、状态模式对\"开闭原则\"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。\n        \n```swift\n  protocol State {\n    func operation()\n}\n\nclass ConcreteStateA: State {\n    func operation() {\n        print(\"A\")\n    }\n}\n\nclass ConcreteStateB: State {\n    func operation() {\n        print(\"B\")\n    }\n}\n\nclass Context {\n    var state: State = ConcreteStateA()\n    func someMethod() {\n        state.operation()\n    }\n}\n  ```\n  \n  4. 策略模式（Strategy）\n    定义：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。    \n    主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。    \n    关键代码：实现同一个接口。    \n    优点： \n        1、算法可以自由切换。 \n        2、避免使用多重条件判断。 \n        3、扩展性良好。    \n    缺点： \n        1、策略类会增多。 \n        2、所有策略类都需要对外暴露。    \n    注意事项：如果一个系统的策略多于四个，会出现策略类膨胀的问题。\n```swift\n// 武器算法\nprotocol WeaponBehavior {\n    func use()\n}\n\n// 挥剑算法\nclass SwordBehavior: WeaponBehavior {\n    func use() { print(\"sword\") }\n}\n\n// 拉弓算法\nclass BowBehavior: WeaponBehavior {\n    func use() { print(\"bow\") }\n}\n\n// 角色\nclass Character {\n    var weapon: WeaponBehavior?\n    func attack() {  weapon?.use() }\n}\n\n// 骑士\nclass Knight: Character {\n    override init() {\n        super.init()\n        weapon = SwordBehavior()\n    }\n}\n\n// 弓箭手\nclass Archer1: Character {\n    override init() {\n        super.init()\n        weapon = BowBehavior()\n    }\n}\n\nclass StrategyContext  {\n    private var strategy:Character?\n    \n    func context(strategy:Character) {\n        self.strategy = strategy\n    }\n    func doSomething() {\n        self.strategy?.weapon?.use()\n    }\n}\n```\n\n5. 职责链模式/责任链模式（Chain of Responsibility）\n6. 定义：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。    \n    主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。    \n    何时使用：在处理消息的时候以过滤很多道。    \n    如何解决：拦截的类都实现统一接口。    \n    使用场景：比如 iosd的触摸事件，touch begin-->winddow-->vc-->view\n```swift\n/// 定义协议\nprotocol TouchEventProtocol {\n    var next: TouchEventProtocol? { get }\n    func touch()\n}\n\n/// 页面 A\nclass ViewA: TouchEventProtocol {\n    var next: TouchEventProtocol? = ViewB()\n    func touch() {\n        next?.touch()\n    }\n}\n\n/// 页面 B\nclass ViewB: TouchEventProtocol {\n    var next: TouchEventProtocol? = ViewC()\n    func touch() {\n        next?.touch()\n    }\n}\n\n/// 页面 C\nclass ViewC: TouchEventProtocol {\n    var next: TouchEventProtocol? = nil\n    func touch() {\n        print(\"C\")\n    }\n}\n```\n6. 命令模式（Command）\n    定义：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。\n    何时使用：在某些场合，比如要对行为进行\"记录、撤销/重做、事务\"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将\"行为请求者\"与\"行为实现者\"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。    \n    如何解决：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。    \n    \n    关键代码：定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口    \n    应用实例：\n```swift\nprotocol Command {\n    /// 操作\n    var operation: () -> Void { get }\n    /// 备份\n    var backup: String { get }\n    // 撤销\n    func undo()\n}\n\nstruct PrintCommand: Command {\n    var operation: () -> Void\n    \n    var backup: String\n    \n    func undo() {\n        print(backup)\n    }\n}\n\nstruct Invoker {\n    var command: Command\n    func execute() {\n        command.operation()\n    }\n    func undo() {\n        command.undo()\n    }\n}\n\nfunc test() {\n    let printA = PrintCommand(operation: {\n        print(\"printA\")\n    }, backup: \"打印机A\")\n\n    let i1 = Invoker(command: printA)\n    i1.execute()\n\n    let printB = PrintCommand(operation: {\n        print(\"printB\")\n    }, backup: \"打印机B\")\n    let i2 = Invoker(command: printB)\n    i2.execute()\n    i2.undo()\n}\n```\n\n7. 访问者模式（Visitor）\n    定义：主要将数据结构与数据操作分离。    \n    主要解决：稳定的数据结构和易变的操作耦合问题。    \n    何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\"污染\"这些对象的类，使用访问者模式将这些封装到类中。    \n    如何解决：在被访问的类里面加一个对外提供接待访问者的接口。    \n    关键代码：在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。    \n    应用实例：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。    \n    优点： \n        1、符合单一职责原则。 \n        2、优秀的扩展性。 \n        3、灵活性。\n使用场景：\n实例\n```swif\n/// 在数据基础类里面有一个方法接受访问者，将自身引用传入访问者\nprotocol VTComponent {\n    func accept(_ v: Visitor)\n}\n\n/// 对象 a\nstruct ComponentA: VTComponent {\n    func featureA() {\n        print(\"Feature A\")\n    }\n    func accept(_ v: Visitor) {\n        v.visit(self)\n    }\n}\n\n/// 对象 b\nstruct ComponentB: VTComponent {\n    func featureB() {\n        print(\"Feature B\")\n    }\n    func accept(_ v: Visitor) {\n        v.visit(self)\n    }\n}\n\n/// 访问者\nprotocol Visitor {\n    func visit(_ c: ComponentA)\n    func visit(_ c: ComponentB)\n}\n\n///\nstruct ConcreteVisitor: Visitor {\n    /// 通过 a\n    func visit(_ c: ComponentA) {\n        c.featureA()\n    }\n    func visit(_ c: ComponentB) {\n        c.featureB()\n    }\n}\n\nfunc test() {\n    let components: [VTComponent] = [ComponentA(), ComponentB()]\n    components.forEach {\n        $0.accept(ConcreteVisitor())\n    }\n}\n```\n8. 中介者模式/调停者模式（Mediator）\n    意图：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。    \n    主要解决：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。    \n    何时使用：多个类相互耦合，形成了网状结构。    \n    如何解决：将上述网状结构分离为星型结构。    \n    关键代码：对象 Colleague 之间的通信封装到一个类中单独处理。    \n    应用实例： \n       1. MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。   \n       \n\n9、备忘录模式（Memento）\n  意图：在不破坏封闭的前提下，将对象当前的内部状态保存在对象之外，之后可以再次恢复到此状态。   \n  Originator：发起者，负责创建一个备忘录，并且可以记录、恢复自身的内部状态。可以根据需要决定Memento保存自身的那些内部状态\n  Memento：备忘录，用于存储Originator的状态，防止Originator以外的的对象访问Memento\n  Caretaker：备忘录管理者，负责存储备忘录，不能对备忘录的内容进行操作和访问，只能够将备忘录传递给其他对象。\n    应用实例： \n       1. 典型的例子就是游戏存档和读档的这个行为 。\n  ```objc\n  // 数据结构\nstruct Memento {\n    var progress: Float = 0\n    var time: Float = 0\n    var pattern:String = \"\"\n}\n\nclass Caretaker {\n    var memento: Memento?\n}\n\nfunc test1() {\n    let game: Game = Game()\n    game.progress = 0.2\n    game.time = 2500\n\n    print(\"当前游戏的模式:\\(game.pattern)---游戏的进度:\\(game.progress)\")\n\n    let caretaker: Caretaker = Caretaker()\n    caretaker.memento = game.saveMemento()\n\n    game.progress = 0.5\n\n    print(\"当前游戏的模式:\\(game.pattern)---游戏的进度:\\(game.progress)\")\n\n    print(\"备份游戏的模式:\\(caretaker.memento!.pattern)---游戏的进度:\\(caretaker.memento!.progress)\")\n}\n  \n  ```\n\n10、迭代器模式（Iterator）\n意图：用于顺序访问集合对象的元素，不需要知道集合对象的底层表示\n优点：\n  它支持以不同的方式遍历一个聚合对象。\n  迭代器简化了聚合类。\n  在同一个聚合上可以有多个遍历。\n  ```swift\n  //定义一个小说结构\nstruct Novella {\n    let name: String //小说名\n}\n\n//定义一个小说集合结构\nstruct Novellas {\n    let novellas: [Novella] //存放的一些小说\n}\n\n//定义一个小说迭代器（遵循Swift的迭代器协议）\nstruct NovellasIterator: IteratorProtocol {\n    \n    private var current = 0 //当前索引\n    private let novellas: [Novella] //小说堆\n    \n    init(novellas: [Novella]) {\n        self.novellas = novellas\n    }\n    \n    //实现协议方法\n    mutating func next() -> Novella? {\n        defer {\n            current += 1 //当方法结束后当前索引值+1\n        }\n        //如果小说集合内的小说数量大于当前索引，则返回当前索引值里的小说，返回nil\n        return novellas.count > current ? novellas[current] : nil\n    }\n}\n\n//将小说集合遵循Swift序列协议\nextension Novellas: Sequence {\n    //实现协议方法(制作一个小说迭代器)\n    func makeIterator() -> NovellasIterator {\n        return NovellasIterator(novellas: novellas)\n    }\n}\n\nlet greatNovellas = Novellas(novellas: [Novella(name: \"The Mist\"), Novella(name: \"The Mist2\")])\n\n//遍历取出小说阅读\nfor novella in greatNovellas {\n    print(\"I 've read: \\(novella)\")\n}\n  ```\n\n11. 解释器模式（Interpreter）\n意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。\n\n主要解决：对于一些固定文法构建一个解释句子的解释器。\n\n何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。\n\n如何解决：构建语法树，定义终结符与非终结符。\n\n关键代码：构建环境类，包含解释器之外的一些全局信息，一般是 HashMap。\n\n应用实例：编译器、运算表达式计算。\n\n优点： 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。\n缺点： 1、可利用场景比较少。 2、对于复杂的文法比较难维护\n```swift\nprotocol Expression {\n    func ruleExpression(_ context: String) -> Int\n}\n\nstruct MyAdditionExpression: Expression {\n    func ruleExpression(_ context: String) -> Int {\n        return context.components(separatedBy: \"加\")\n            .compactMap { Int($0) }\n            .reduce(0, +)\n    }\n}\n```\n\n## 总结\n1. 读这本书的时候，先思考项目中有没有这方面的设计模式，在进一步思考该设计模式解决什么问题以及使用场景\n2. 如果没有使用到这一设计模式，通过写 domo 测试代码来加深理解。\n3. 项目中可以尝试落地的设计模式，比如：打印机可以使用抽象工厂模式，以及策略模式。开单的 composer 可以使用策略模式，来确定使用\n那种开单的 composer。\n\n\n[Swift 设计模型指南](<https://www.raywenderlich.com/2102-intermediate-design-patterns-in-swift>)\n[设计模式](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)\n\n\n\n\n    \n\n"
    },
    {
      "type": "text",
      "data": ""
    }
  ]
}