{
  "title": "swift学习",
  "cells": [
    {
      "type": "markdown",
      "data": "### 数值型字面量\n1. 整数字面量可以被写作:\n    一个十进制数，没有前缀\n    一个二进制数，前缀是0b\n    一个八进制数，前缀是0o\n    一个十六进制数，前缀是0x\n\n```swift\nlet numInt = 12345   // 十进制\nlet numCctal = 0o17 // 8进制\nlet numBinary = 0x10 // 2进制\nlet numHex = 0x1f    // 16进制\n```\n\n### 类型别名 typealias\n相当于oc里面的typeof的用法，可以定义一个类型的别名\n```\ntypealias IntType = UInt8\nlet maxUint8 = IntType.max;// 255\n```\n### 元组 \n元组可以是任意类型组成的复合值，比如网络请求的返回状态404，“Not Found”\n```\nlet httpStatus = (404, \"Not Found\") // 元祖里面的类型为int, string\n// 打印\nprint(httpStatus.0)\nprint(httpStatus.1)\n// 也可以赋值到另外一个有类型别名的元祖\nlet (statusCode,statusMessage) = httpStatus\nprint (statusCode)\nprint (statusMessage)\n\n// 也可以元组给单个元素命名\nlet http202Status = (statusCode:202, description:\"ok\")\nprint (http202Status.statusCode)\nprint (http202Status.description)\n```\n\n### nil\n1. nil可以给可选变量赋值为Nil来表示他没有值\n```\nvar serverResponseCode:Int? = 404\nserverResponseCode = nil // 可以赋值给柯可选类型nil\n// 不能给指定类型赋值nil\n// var serverStatusCode:Int = nil // 编译错误\n注意: nil不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。\n```\n### ！可选值类型解析\n1. 当你确定可选类型包含实际值之后，可以在可选名字加!来获取值。才确保他有实际值\n\n### 可选绑定\n使用可选绑定（optional binding）来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在 if 和 while 语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可以将可选类型中的值赋给一个常量或者变量\n```\nif let constantName = someOptional {\n    statements\n}\n```\n\n### 异常处理\n```\ndo {\n    try catch throws\n}catch let error {\n    \n}\n```\n\n### assert 断言\n```objc\nlet age = -3;\n// 断言如果不为true, 则输出\nassert(age >= 0, \"年龄不能为负数\")\n```\n\n// 循环控制for 的区间运算符\n闭区间运算符（a...b）定义一个包含从 a 到 b（包括 a 和 b）的所有值的区间\n```objc\n// {1,5}闭区间\nfor num in 1 ... 5 {\n    print(\"num = \\(num)\")\n}\n\n```\n半开区间运算符(a ... < b)\n\n## 字符串\n### 初始化字符串\n```\n//这两个初始化为空并等价\nvar emptyString = \"\"               // 空字符串字面量\nvar anotherEmptyString = String()  // 初始化方法\n```\n### 遍历字符串每个字符\n```\n// 遍历字符串\nvar string = \"hello, world\"\nfor characters in string.characters {\n    print (characters)\n}\n```\n\n### 数组\n\n## get/setter方法\n```objc\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    var center: Point {\n        get {\n            let centerX = origin.x + (size.width / 2)\n            let centerY = origin.y + (size.height / 2)\n            return Point(x: centerX, y: centerY)\n        }\n        set(newCenter) {\n            origin.x = newCenter.x - (size.width / 2)\n            origin.y = newCenter.y - (size.height / 2)\n        }\n    }\n}\n```\n\n## kvo观察属性\n会以oldValue为默认参数传递\n```objc\nclass StepCounter {\n    var totalSteps: Int = 0 {\n        willSet(newTotalSteps) {\n            print(\"About to set totalSteps to \\(newTotalSteps)\")\n        }\n        didSet {\n            if totalSteps > oldValue  {\n                print(\"Added \\(totalSteps - oldValue) steps\")\n            }\n        }\n    }\n}\n```\n\n## 全局变量和局部变量\n全局的常量或变量都是延迟计算的，不用设置lazy修饰符，但都是延迟加载。\n局部变量或常量从不延迟计算\n\n### 防止重写\n属性和方法用final关键字预防子类重写\n\n## where关键字\n```objc\nprotocol aProtocol{}\nextension aProtocol where Self:UIView{\n    //只给遵守myProtocol协议的UIView添加了拓展\n    //强大的协议拓展  可以给协议添加默认实现   面向协议编程的基础\n    func getString() -> String{\n        return \"string\"\n    }\n\n}\n```\n\n### @escaping\n可以让block的声明周期延长，确保block能成功回调到\n\n### func里面的默认参数都是let类型，又必要的时候需要把他改成var\n```swift\nfunc makeIncrementor(addNumber: Int) -> ((inout Int) -> ()) {\n\nfunc incrementor(variable: inout Int) -> () {\n\nvariable += addNumber;\n\n}\n\nreturn incrementor;\n\n}\n```\n\n### 字⾯量表达\n数组： let array = [1, 2, 3, 4]\n\n### typealias 等价于typedef \n\n\n\n  "
    }
  ]
}