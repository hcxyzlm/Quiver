{
  "title": "llvm编译原理和调优",
  "cells": [
    {
      "type": "markdown",
      "data": "\n## 相关文献\n1. [llvm架构的一个概述](http://www.aosabook.org/en/llvm.html)\n## LLVM简介\n1. LLVM是一个模块化和可重用的编译器和工具链技术的集合，相当于gdb是一个编译器工具集合。\n2. iOS 开发中 Objective-C 是 Clang / LLVM 来编译的\n\n\n## clang简介\n1. Clang 是 LLVM 的子项目，比gcc快三倍，是c/c++,object-c的编译器，在狭义上讲，llvm包含了clang, clang只是作为编译器的前端工具，负责主要处理一些和具体机器无关的针对语言的分析操\n\n## llvm和clang的关系\n![IMAGE](quiver-image-url/CBB224E8A15EB7CBE151A8A45BEF8C7C.jpg =623x422)\n\n##编译流程\n词法->语法->语义->IR->优化->CodeGen\n\n1. 简单的例子\n```object-c\n#import <Foundation/Foundation.h>\n#define DEFINEEight 8\n\nint main(){\n    @autoreleasepool {\n        int eight = DEFINEEight;\n        int six = 6;\n        NSString* site = [[NSString alloc] initWithUTF8String:\"starming\"];\n        int rank = eight + six;\n        NSLog(@\"%@ rank %d\", site, rank);\n    }\n    return 0;\n}\n```\n2. 在命令行编译 clang -ccc-print-phases main.m \n可以看出编译源文件需要的几个不同的阶段\n0: input, \"main.m\", objective-c\n1: preprocessor, {0}, objective-c-cpp-output\n2: compiler, {1}, ir\n3: backend, {2}, assembler\n4: assembler, {3}, object\n5: linker, {4}, image\n6: bind-arch, \"x86_64\", {5}, image\n\n3. 查看oc的c实现可以使用如下命令\n  clang -rewrite-objc main.m\n  \n4.查看操作内部命令，可以使用 -### 命令\n1. clang -### main.m -o main\n\n5. 想看清clang的全部过程，可以先通过-E查看clang在预处理处理这步做了什么\n这个过程的处理包括宏的替换，头文件的导入，以及类似#if的处理。预处理完成后就会进行词法分析，这里会把代码切成一个个 Token，比如大小括号，等于号还有字符串等。\n\n然后是语法分析，验证语法是否正确，然后将所有节点组成抽象语法树 AST\nclang -fmodules -fsyntax-only -Xclang -ast-dump main.m\n\n完成这些步骤后就开始IR中间代码的生成了，CodeGun会负责向语法树自顶向下遍历逐步翻译成llvm ir,ir是编译过程的前端的输出，后端的输入\n\nclang -S -fobjc-arc -emit-llvm main.m -o main.ll， 这里llvm会去做优化的工作，在xcode的编译设置也可以设置优先级为01，02，03还可以自己写些自己的pass.\n\n如果开启了 bitcode 苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。\nclang -emit-llvm -c main.m -o main.bc\n\n生成汇编\nclang -S -fobjc-arc main.m -o main.s\n\n生成目标文件\nclang -fmodules -c main.m -o main.o\n\n生成可执行文件，并看到结果\n\n## ios工程编译完整步骤：\n  编译信息写入辅助文件，创建文件架构 .app 文件\n  处理文件打包信息\n  执行 CocoaPod 编译前脚本，checkPods Manifest.lock\n  编译.m文件，使用 CompileC 和 clang 命令\n  链接需要的 Framework\n  编译 xib\n  拷贝 xib ，资源文件\n  编译 ImageAssets\n  处理 info.plist\n  执行 CocoaPod 脚本\n  拷贝标准库\n  创建 .app 文件和签名\n  Clang 编译 .m 文件\n  \n  ## xcode查看编译流程\n  1.![IMAGE](quiver-image-url/097EFEA493302E617C4861C262769B29.jpg =328x318)\n  2. 点击build-->就会看到所有.m文件编译过程\n  ![IMAGE](quiver-image-url/170B4A307078CB6339C8FDFD9D226236.jpg =934x232)\n  \n  \n  ## clang编译选项\n  \n  - x 编译语言比如objective-c\n  -arch 编译的架构，比如arm7\n  -f 以-f开头的\n  -W 以-W开头的，可以通过这些定制编译警告\n  -D 以-D开头的，指的是预编译宏，通过这些宏可以实现条件编译\n  -iPhoneSimulator10.1.sdk 编译采用的iOS SDK版本\n  -I 把编译信息写入指定的辅助文件\n  -F 需要的Framework\n  -c 标识符指明需要运行预处理器，语法分析，类型检查，LLVM生成优化以及汇编代码生成.o文件\n  -o 编译结果\n  \n  ##ios工程target\n  1. build 过程控制的这些设置都会被保存在工程文件 .pbxproj 里。在这个文件中可以找 rootObject 的 ID 值\n\nrootObject = 3EE311301C4E1F0800103FA3 /* Project object */;\n\n## clang Analyzer 静态代码分析\n1. clang -fmodules -E -Xclang -dump-tokens main.m\n\n## Clang Attributes\n\n1. attribute((format(NSString, F, A))) 格式化字符串\n可以查看NSLog的用法\n2. attribute((deprecated(s))) 版本弃用提示\n- (void)setupDisplayFiltering __attribute__((deprecated((\"preMethod已经被弃用，请使用newMethod\"))));\n3.attribute((availability(os,introduced=m,deprecated=n, obsoleted=o,message=\"\" VA_ARGS))) 指明使用版本范围\nos 指系统的版本，m 指明引入的版本，n 指明过时的版本，o 指完全不用的版本，message 可以写入些描述信息。\n- (void)method __attribute__((availability(ios,introduced=3_0,deprecated=6_0,obsoleted=7_0,message=\"iOS3到iOS7版本可用，iOS7不能用\")));\n4. attribute((unavailable(…))) 方法不可用提示,会提示，还会编译失败\n  __attribute__((unavailable(\"方法不可用\")))\n5. \n\n"
    }
  ]
}