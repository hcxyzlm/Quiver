{
  "title": "wcdb",
  "cells": [
    {
      "type": "markdown",
      "data": "### 简介\nwcdb是微信开源基于 SQLCipher，易用的移动数据库框架。\nAbout WCDB : [Tencent/WCDB](https://github.com/Tencent/wcdb) , [微信WCDB进化之路 - 开源与开始](https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ%3D%3D&mid=2649286603&idx=1&sn=d243dd27f2c6614631241cd00570e853&chksm=8334c349b4434a5fd81809d656bfad6072f075d098cb5663a85823e94fc2363edd28758ab882&mpshare=1&scene=1&srcid=0609GLAeaGGmI4zCHTc2U9ZX)。\n\n### 将一个已有的OC类进行QRM绑定的过程\n1. 需要实现WCTTableCoding协议\n2. 把WCTTableCoding协议新建到一个分类，来膈应c++代码，让引用oc的类不用改名成mm文件\n### 创建model\nLMKeyValueItem.h\n```objc-c\n@interface LMKeyValueItem : NSObject\n@property (strong, nonatomic) NSString *itemId;\n@property (strong, nonatomic) NSString *itemObject;\n@property (strong, nonatomic) NSDate *createdTime;\n@end\n````\n\nLMKeyValueItem.mm\n\n```objc-c\n// 利用这个宏定义绑定到表的类\nWCDB_IMPLEMENTATION(LMKeyValueItem)\n\n// 这个宏把oc类变量与表中的字段对应\nWCDB_SYNTHESIZE_COLUMN(LMKeyValueItem, itemId,\"id\")\nWCDB_SYNTHESIZE_COLUMN(LMKeyValueItem, itemObject, \"json\")\nWCDB_SYNTHESIZE_COLUMN(LMKeyValueItem, createdTime, \"createdTime\")\n\n@end\n````\n\nLMKeyValueItem+WCTTableCoding.h\n```objc-c\n@interface LMKeyValueItem (WCTTableCoding) <WCTTableCoding>\n\n// 需要绑定到表中的字段在这里声明，在.mm中去绑定\nWCDB_PROPERTY(itemId)\nWCDB_PROPERTY(itemObject)\nWCDB_PROPERTY(createdTime)\n\n@end \n```\n\n### 新建一个类简单简单封装增删改差\n\nLMWCDBOperation.h\n```objc\n@interface LMWCDBOperation : NSObject\n\n@property (nonatomic, strong, readonly) WCTDatabase *dbDatabase;\n\n- (nullable instancetype)init UNAVAILABLE_ATTRIBUTE;\n\n+ (nullable instancetype)new UNAVAILABLE_ATTRIBUTE;\n\n- (instancetype )initDBWithName:(NSString *)dbName;\n\n- (instancetype )initWithDBWithPath:(NSString *)dbPath;\n\n#pragma mark insert\n- (BOOL)insertObject:(NSObject *)object\n                into:(NSString *)tableName;\n\n#pragma mark - Get Object\n\n/**\n 从数据库查找model\n\n @param cls class\n @param tableName 表名\n @param columnName model id 对应绑定数据库的名称\n @param realID 实参，找到realID的模型，id类型只接受NSString和NSNumber类型，其他会报错\n */\n- (id)getOneObjectOfClass:(Class)cls fromTable:(NSString *)tableName bandingColumnName:(NSString *)columnName realID:(id)realID;\n\n#pragma mark Update With Object\n\n/**\n 根据传入id参数更新数据库\n\n @param tableName 表名\n @param object 更新的model\n @param columnName 绑定的数据库参数\n @param realID id类型只接受NSString和NSNumber类型，其他会报错\n */\n- (BOOL)updateObjectInTable:(NSString *)tableName withObject:(NSObject *)object bandingColumnName:(NSString *)columnName realID:(id)realID;\n\n#pragma mark delete object\n\n/**\n 从数据库删除模型\n\n @param tableName 表名\n @param columnName 绑定id对应数据库字段名\n @param realID id类型只接受NSString和NSNumber类型，其他会报错\n */\n- (BOOL)deleteObjectFromTable:(NSString *)tableName bandingColumnName:(NSString *)columnName realID:(id)realID;\n\n@end\n```\n\n### 简单用法\n```objc-c\n    LMKeyValueItem *keyValueItem = [[LMKeyValueItem alloc] init];\n    keyValueItem.itemId = cacheKey;\n    keyValueItem.itemObject = jsonValue;\n    keyValueItem.createdTime = [NSDate date];\n    // 简单存储\n    [[LMWCDBOperation shareOperation] insertObject:keyValueItem into:TABLE_NAME_KEYVALUE];\n```\n\n### 用模型的分类来实现更为复杂的操作数据库逻辑\n1.避免引用wcdb文件，不需要改名为mm文件\n2.逻辑更被清晰，不用所有的操作都写到一个文件中，不容易维护\nLMAnnouncer+DBManager.h\n```objc-c\n@interface LMAnnouncer (DBManager)\n\n+ (BOOL)insertAnnouncerDetailWith:(LMAnnouncer *)announcer;\n\n+ (void)insertAnnouncersDetailWith:(NSArray *)announcers;\n\n+ (NSArray *)queryAnnouncersDetailWithIds:(NSArray *)announcerIds;\n\n@end\n```\n\n```objc-c\nLMAnnouncer+DBManager.mm\n+ (BOOL)insertAnnouncerDetailWith:(LMAnnouncer *)announcer\n{\n    NSString *nickName = [announcer.nickName stringByReplacingOccurrencesOfString:@\"'\" withString:@\"''\"];\n    NSString *cover = [announcer.cover stringByReplacingOccurrencesOfString:@\"'\" withString:@\"''\"];\n    NSString *sign = [announcer.sign stringByReplacingOccurrencesOfString:@\"'\" withString:@\"''\"];\n    NSString *desc = [announcer.desc stringByReplacingOccurrencesOfString:@\"'\" withString:@\"''\"];\n    if (![[LMWCDBOperation shareOperation].dbDatabase isTableExists:TABLE_NAME_ANNOUNCERDETAIL]) {\n        BOOL result = [[LMWCDBOperation shareOperation].dbDatabase createTableAndIndexesOfName:TABLE_NAME_ANNOUNCERDETAIL withClass:self.class];\n        if (!result) {\n            return result;\n        }\n    }\n    \n    \n    BOOL result = [[LMWCDBOperation shareOperation].dbDatabase insertObject:announcer into:TABLE_NAME_ANNOUNCERDETAIL];\n    \n    return result;\n}\n```\n\n### 使用wcdb需要注意点\n1. 原本用fmdb对字段约束为NOT NULL非空，在wcdb这个字段不能插入非空的字符串，会报错\n2. 原来的fmdb oc类对应数据表的对应字段名，要用WCDB_SYNTHESIZE_COLUMN跟原始的sql绑定在一起\n比如：\n```objc-c\nstatic NSString *const CREATE_TABLE_SQL =\n@\"CREATE TABLE IF NOT EXISTS %@ ( \\\nid TEXT NOT NULL, \\\njson TEXT NOT NULL, \\\ncreatedTime TEXT NOT NULL, \\\nPRIMARY KEY(id)) \\\n\";\n```\nYTKKeyValueItem的itemId字段绑定表的id\n你在mm文件绑定：\n```objc\nWCDB_SYNTHESIZE_COLUMN(LMKeyValueItem, itemId,\"id\")\n```\n\n### 讨论点\n1. 是否可以抛弃原来的fmdb原来的绑定名，用wcdb新的绑定字段，是否对升级上来的用户会有影响？\n\n\n"
    }
  ]
}