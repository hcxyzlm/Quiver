{
  "title": "objc_msg的源码实现",
  "cells": [
    {
      "type": "markdown",
      "data": "一般oc调用都会变成id objc_msgSend(id self, SEL op, ...);这个方法。本文来研究这个函数的具体实现\n由于objc_msgSend是所有oc方法调动的核心，为了保证性能，用了汇编语言来实现。\n```objc\n     ;这里列出的是在arm64位真机模式下的汇编代码实现。\n    0x18378c420 <+0>:   cmp    x0, #0x0                  ; =0x0 \n    0x18378c424 <+4>:   b.le   0x18378c48c               ; <+108>\n    0x18378c428 <+8>:   ldr    x13, [x0]\n    0x18378c42c <+12>:  and    x16, x13, #0xffffffff8\n    0x18378c430 <+16>:  ldp    x10, x11, [x16, #0x10]\n    0x18378c434 <+20>:  and    w12, w1, w11\n    0x18378c438 <+24>:  add    x12, x10, x12, lsl #4\n    0x18378c43c <+28>:  ldp    x9, x17, [x12]\n    0x18378c440 <+32>:  cmp    x9, x1\n    0x18378c444 <+36>:  b.ne   0x18378c44c               ; <+44>\n    0x18378c448 <+40>:  br     x17\n    0x18378c44c <+44>:  cbz    x9, 0x18378c720           ; _objc_msgSend_uncached\n    0x18378c450 <+48>:  cmp    x12, x10\n    0x18378c454 <+52>:  b.eq   0x18378c460               ; <+64>\n    0x18378c458 <+56>:  ldp    x9, x17, [x12, #-0x10]!\n    0x18378c45c <+60>:  b      0x18378c440               ; <+32>\n    0x18378c460 <+64>:  add    x12, x12, w11, uxtw #4\n    0x18378c464 <+68>:  ldp    x9, x17, [x12]\n    0x18378c468 <+72>:  cmp    x9, x1\n    0x18378c46c <+76>:  b.ne   0x18378c474               ; <+84>\n    0x18378c470 <+80>:  br     x17\n    0x18378c474 <+84>:  cbz    x9, 0x18378c720           ; _objc_msgSend_uncached\n    0x18378c478 <+88>:  cmp    x12, x10\n    0x18378c47c <+92>:  b.eq   0x18378c488               ; <+104>\n    0x18378c480 <+96>:  ldp    x9, x17, [x12, #-0x10]!\n    0x18378c484 <+100>: b      0x18378c468               ; <+72>\n    0x18378c488 <+104>: b      0x18378c720               ; _objc_msgSend_uncached\n    0x18378c48c <+108>: b.eq   0x18378c4c4               ; <+164>\n    0x18378c490 <+112>: mov    x10, #-0x1000000000000000\n    0x18378c494 <+116>: cmp    x0, x10\n    0x18378c498 <+120>: b.hs   0x18378c4b0               ; <+144>\n    0x18378c49c <+124>: adrp   x10, 202775\n    0x18378c4a0 <+128>: add    x10, x10, #0x220          ; =0x220 \n    0x18378c4a4 <+132>: lsr    x11, x0, #60\n    0x18378c4a8 <+136>: ldr    x16, [x10, x11, lsl #3]\n    0x18378c4ac <+140>: b      0x18378c430               ; <+16>\n    0x18378c4b0 <+144>: adrp   x10, 202775\n    0x18378c4b4 <+148>: add    x10, x10, #0x2a0          ; =0x2a0 \n    0x18378c4b8 <+152>: ubfx   x11, x0, #52, #8\n    0x18378c4bc <+156>: ldr    x16, [x10, x11, lsl #3]\n    0x18378c4c0 <+160>: b      0x18378c430               ; <+16>\n    0x18378c4c4 <+164>: mov    x1, #0x0\n    0x18378c4c8 <+168>: movi   d0, #0000000000000000\n    0x18378c4cc <+172>: movi   d1, #0000000000000000\n    0x18378c4d0 <+176>: movi   d2, #0000000000000000\n    0x18378c4d4 <+180>: movi   d3, #0000000000000000\n    0x18378c4d8 <+184>: ret    \n    0x18378c4dc <+188>: nop    \n\n```\n\n翻译成c语言代码\n```objc\n//下面的结构体中只列出objc_msgSend函数内部访问用到的那些数据结构和成员。\n\n/*\n其实SEL类型就是一个字符串指针类型，所描述的就是方法字符串指针\n*/\ntypedef char * SEL;\n\n/*\nIMP类型就是所有OC方法的函数原型类型。\n*/\ntypedef id (*IMP)(id self, SEL _cmd, ...); \n\n\n/*\n  方法名和方法实现桶结构体\n*/\nstruct bucket_t  {\n    SEL  key;       //方法名称\n    IMP imp;       //方法的实现，imp是一个函数指针类型\n};\n\n/*\n   用于加快方法执行的缓存结构体。这个结构体其实就是一个基于开地址冲突解决法的哈希桶。\n*/\nstruct cache_t {\n    struct bucket_t *buckets;    //缓存方法的哈希桶数组指针，桶的数量 = mask + 1\n    int  mask;        //桶的数量 - 1\n    int  occupied;   //桶中已经缓存的方法数量。\n};\n\n/*\n    OC对象的类结构体描述表示，所有OC对象的第一个参数保存是的一个isa指针。\n*/\nstruct objc_object {\n  void *isa;\n};\n\n/*\n   OC类信息结构体，这里只展示出了必要的数据成员。\n*/\nstruct objc_class : objc_object {\n    struct objc_class * superclass;   //基类信息结构体。\n    cache_t cache;    //方法缓存哈希表\n    //... 其他数据成员忽略。\n};\n\n\n\n/*\nobjc_msgSend的C语言版本伪代码实现.\nreceiver: 是调用方法的对象\nop: 是要调用的方法名称字符串\n*/\nid  objc_msgSend(id receiver, SEL op, ...)\n{\n\n    //1............................ 对象空值判断。\n    //如果传入的对象是nil则直接返回nil\n    if (receiver == nil)\n        return nil;\n    \n   //2............................ 获取或者构造对象的isa数据。\n    void *isa = NULL;\n    //如果对象的地址最高位为0则表明是普通的OC对象，否则就是Tagged Pointer类型的对象\n    if ((receiver & 0x8000000000000000) == 0) {\n        struct objc_object  *ocobj = (struct objc_object*) receiver;\n        isa = ocobj->isa;\n    }\n    else { //Tagged Pointer类型的对象中没有直接保存isa数据，所以需要特殊处理来查找对应的isa数据。\n        \n        //如果对象地址的最高4位为0xF, 那么表示是一个用户自定义扩展的Tagged Pointer类型对象\n        if (((NSUInteger) receiver) >= 0xf000000000000000) {\n            \n            //自定义扩展的Tagged Pointer类型对象中的52-59位保存的是一个全局扩展Tagged Pointer类数组的索引值。\n            int  classidx = (receiver & 0xFF0000000000000) >> 52\n            isa =  objc_debug_taggedpointer_ext_classes[classidx];\n        }\n        else {\n            \n            //系统自带的Tagged Pointer类型对象中的60-63位保存的是一个全局Tagged Pointer类数组的索引值。\n            int classidx = ((NSUInteger) receiver) >> 60;\n            isa  =  objc_debug_taggedpointer_classes[classidx];\n        }\n    }\n    \n   //因为内存地址对齐的原因和虚拟内存空间的约束原因，\n   //以及isa定义的原因需要将isa与上0xffffffff8才能得到对象所属的Class对象。\n    struct objc_class  *cls = (struct objc_class *)(isa & 0xffffffff8);\n    \n   //3............................ 遍历缓存哈希桶并查找缓存中的方法实现。\n    IMP  imp = NULL;\n    //cmd与cache中的mask进行与计算得到哈希桶中的索引，来查找方法是否已经放入缓存cache哈希桶中。\n    int index =  cls->cache.mask & op;\n    while (true) {\n        \n        //如果缓存哈希桶中命中了对应的方法实现，则保存到imp中并退出循环。\n        if (cls->cache.buckets[index].key == op) {\n              imp = cls->cache.buckets[index].imp;\n              break;\n        }\n        \n        //方法实现并没有被缓存，并且对应的桶的数据是空的就退出循环\n        if (cls->cache.buckets[index].key == NULL) {\n             break;\n        }\n        \n        //如果哈希桶中对应的项已经被占用但是又不是要执行的方法，则通过开地址法来继续寻找缓存该方法的桶。\n        if (index == 0) {\n            index = cls->cache.mask;  //从尾部寻找\n        }\n        else {\n            index--;   //索引减1继续寻找。\n        }\n    } /*end while*/\n\n   //4............................ 执行方法实现或方法未命中缓存处理函数\n    if (imp != NULL)\n         return imp(receiver, op,  ...); //这里的... 是指传递给objc_msgSend的OC方法中的参数。\n    else\n         return objc_msgSend_uncached(receiver, op, cls, ...);\n}\n\n/*\n  方法未命中缓存处理函数：objc_msgSend_uncached的C语言版本伪代码实现，这个函数也是用汇编语言编写。\n*/\nid objc_msgSend_uncached(id receiver, SEL op, struct objc_class *cls)\n{\n   //这个函数很简单就是直接调用了_class_lookupMethodAndLoadCache3 来查找方法并缓存到struct objc_class中的cache中，最后再返回IMP类型。\n  IMP  imp =   _class_lookupMethodAndLoadCache3(receiver, op, cls);\n  return imp(receiver, op, ....);\n}\n\n```\n\n1. 对象空值判断\n首先对传进来的方法接收者receiver进行是否为空判断，如果是nil则函数直接返回，这也就说明了当对一个nil对象调用方法时，不会产生崩溃，也不会进入到对应的方法实现中去，整个过程其实什么也不会发生而是直接返回nil"
    }
  ]
}