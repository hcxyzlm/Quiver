{
  "title": "CFNetWork详解",
  "cells": [
    {
      "type": "markdown",
      "data": "## 概念\nios的网络层次模型分为三层\n1. Cocoa层：NSURL，Bonjour，Game Kit，WebKit\n2. core foundation层: 基于c的cfnetwork和CFNetServices\n3. os层: 基于c的bsd socket\n\n## CFNetwork只是对bsd的socket进行了轻量级封装，而且和run-loop相结合，每一个线程都有自己的runloop\n，可以在runloop里面做相应的处理\n\n## cfstream的步骤\n1. 创建一对stream的接口，一个用于读，一个用于写\n```objc\nvoid CFStreamCreatePairWithSocketToHost ( CFAllocatorRef alloc, CFStringRef host, UInt32 port, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream );\n\n// 参数: alloc 一般用于分配kCFAllocatorDefault \n   host: 主机名\n   port: 端口\n   readStream: 用于读\n   writeStream：用于写\n```\n\n2. 设置读写的回调\n```objc\nBoolean CFReadStreamSetClient(CFReadStreamRef stream, CFOptionFlags streamEvents, CFReadStreamClientCallBack clientCB, CFStreamClientContext *clientContext);\n\nBoolean CFWriteStreamSetClient(CFWriteStreamRef stream, CFOptionFlags streamEvents, CFWriteStreamClientCallBack clientCB, CFStreamClientContext *clientContext);\n\n参数: streamEvents 设置标记来表明我们对哪些感兴趣，常见的有\ntypedef CF_OPTIONS(CFOptionFlags, CFStreamEventType) {\n    kCFStreamEventNone = 0,\n    kCFStreamEventOpenCompleted = 1,\n    kCFStreamEventHasBytesAvailable = 2,\n    kCFStreamEventCanAcceptBytes = 4, \n    kCFStreamEventErrorOccurred = 8,\n    kCFStreamEventEndEncountered = 16\n};\nclientCB:是一个参数回调\nclientContext: 是一个上下文，一般为CFStreamClientContext info = {0, (void*)self, NULL, NULL, NULL}\n```\n3. 设置好回调后，就可以把stream， write设置到runloop，因为这些读写操作是异步的。\n```objc\nvoid CFReadStreamScheduleWithRunLoop(CFReadStreamRef stream, CFRunLoopRef runLoop, CFStringRef runLoopMode);\n\nvoid CFWriteStreamScheduleWithRunLoop(CFWriteStreamRef stream, CFRunLoopRef runLoop, CFStringRef runLoopMode);\n```\n4. 打开读写操作\n```objc\nBoolean CFReadStreamOpen ( CFReadStreamRef stream );\nBoolean CFWriteStreamOpen ( CFWriteStreamRef stream );\n```\n\n5. 注意，当我们不再关心stream的事件处理的时候，可以把读写事件从runloop移除。\n```objc\nFReadStreamUnscheduleFromRunLoop(CFReadStreamRef stream, CFRunLoopRef runLoop, CFStringRef runLoopMode);\n\nvoid CFWriteStreamUnscheduleFromRunLoop(CFWriteStreamRef stream, CFRunLoopRef runLoop, CFStringRef runLoopMode);\n```\n\n6.当socket的网络事件调度到run-loop之后，我们就能在回调函数中处理各种事件。\n比如:kCFStreamEventHasBytesAvailable 读取数据\n```objc\nBoolean CFReadStreamHasBytesAvailable(CFReadStreamRef stream);\n\nCFIndex CFReadStreamRead(CFReadStreamRef stream, UInt8 *buffer, CFIndex bufferLength);\n```\nkCFStreamEventCanAcceptBytes\n```objc\nBoolean CFWriteStreamCanAcceptBytes(CFWriteStreamRef stream);\n\nCFIndex CFWriteStreamWrite(CFWriteStreamRef stream, const UInt8 *buffer, CFIndex bufferLength);\n````\n\n7. 关闭读写流\n"
    }
  ]
}