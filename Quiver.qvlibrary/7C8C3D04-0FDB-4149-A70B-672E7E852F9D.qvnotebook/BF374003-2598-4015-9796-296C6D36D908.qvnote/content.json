{
  "title": "深浅拷贝浅析",
  "cells": [
    {
      "type": "markdown",
      "data": "1. 如果想使用copy 和 mutableCopy,必须实现分别实现NSCopying 和NSMutableCopying， 即分别实现copyWithZone:和mutableCopyWithZone:两个方法\n\n## 1、首先说说深浅copy\n浅copy:指针复制，不会创建一个新的对象。\n深copy:内容复制，会创建一个新的对象。\n\n### 检验深浅拷贝的准则\n1. 探究框架类深copy还是浅copy，需要清楚的是该类如何实现的NSCopying和NSMutableCopy的两个方法copyWithZone:和mutableCopyWithZone:\n```objc \n对immutableObject，即不可变对象，执行copy，会得到不可变对象，并且是浅copy。\n对immutableObject，即不可变对象，执行mutableCopy，会得到可变对象，并且是深copy。\n对mutableObject，即可变对象，执行copy，会得到不可变对象，并且是深copy。\n对mutableObject，即可变对象，执行mutableCopy，会得到可变对象，并且是深copy。\n```\n\n### 例子\n```objc\n        NSString *str = @\"1\";\n        NSString *str1 = [str copy];  // 浅拷贝\n        NSString *str2 = [str mutableCopy]; // 浅拷贝\n        \n        // 可变对象\n        NSMutableString *mutableStr = [NSMutableString stringWithString:@\"1\"];\n        NSMutableString *mutableStr1 = [mutableStr copy];// 深拷贝\n        NSMutableString *mutableStr2 = [mutableStr mutableCopy];// 深拷贝\n```\n\n## 自定义类的深浅拷贝\n对于继承NSObject的自定义类，深浅拷贝则要看实现协议copying，自定义的类就和2中的原则没有半毛钱关系了，一切就看你怎么实现NSCopying协议中的copyWithZone:方法\n// 浅拷贝\n```objec\n@interface testCopyObject () <NSCopying>\n\n@end\n\n@implementation testCopyObject \n// 浅拷贝\n- (id)copyWithZone:(nullable NSZone *)zone {\n    \n    return self;\n}\n```\n\n// 深拷贝\n```objc\n@interface testCopyObject () <NSCopying>\n\n@end\n\n@implementation testCopyObject \n\n- (id)copyWithZone:(nullable NSZone *)zone {\n    \n    testCopyObject *model = [[testCopyObject alloc] init];\n    model.age = self.age;\n    model.name = self.name;\n    model.work = self.work;\n    \n    return model;\n}\n```\n\n\n## 二、容器对象的深浅copy\n### 1、浅copy\n1. 容器的浅copy，符合三.2中的原则\n```objc \nNSArray *arr = [NSArray arrayWithObjects:@\"1\", nil];\nNSArray *copyArr = [arr copy]; // 浅拷贝\n```\n###2. 单层深copy\n1. 容器的单层深copy，符合三.2中的原则（只是深copy变成了单层深copy)，容器本身完成了深拷贝，但是容器存放的对象是浅拷贝\n```objc\nNSArray *arr = [NSArray arrayWithObjects:@\"1\", nil];\nNSArray *copyArr = [arr mutableCopy];\n// arr 和 copyArr的地址不同，但是arr[0]和copyArr[0]地址相同\n```\n\n### 3、双层深copy\n准则\n容器的双层深copy已经脱离了三.2中的原则。这里的双层指的是完成了NSArray对象和NSArray容器内对象的深copy（为什么不说完全，是因为无法处理NSArray中还有一个NSArray这种情况）。\n```objec\n// 随意创建一个NSMutableString对象\nNSMutableString *mutableString = [NSMutableString stringWithString:@\"1\"];\n// 随意创建一个包涵NSMutableString的NSMutableArray对象\nNSMutableString *mutalbeString1 = [NSMutableString stringWithString:@\"1\"];\nNSMutableArray *mutableArr = [NSMutableArray arrayWithObjects:mutalbeString1, nil];\n// 将mutableString和mutableArr放入一个新的NSArray中\nNSArray *testArr = [NSArray arrayWithObjects:mutableString, mutableArr, nil];\n// 通过官方文档提供的方式创建copy\nNSArray *testArrCopy = [[NSArray alloc] initWithArray:testArr copyItems:YES];\n\n// testArr和testArrCopy指针对比\nNSLog(@\"%p\", testArr);\nNSLog(@\"%p\", testArrCopy);\n\n// testArr和testArrCopy中元素指针对比\n// mutableString对比\nNSLog(@\"%p\", testArr[0]);\nNSLog(@\"%p\", testArrCopy[0]);\n// mutableArr对比\nNSLog(@\"%p\", testArr[1]);\nNSLog(@\"%p\", testArrCopy[1]);\n\n// mutableArr中的元素对比，即mutalbeString1对比\nNSLog(@\"%p\", testArr[1][0]);\nNSLog(@\"%p\", testArrCopy[1][0]);\n```\n结果分析:这里可以发现，copy后，只有mutableArr中的mutalbeString1指针地址没有变化。而testArr的指针和testArr中的mutableArr、mutableString的指针地址均发生变化。所以称之为双层深复制。\n2016-10-21 12:03:15.549 Memory[67855:5668888] 0x60800003c7a0\n2016-10-21 12:03:15.549 Memory[67855:5668888] 0x60800003c880\n2016-10-21 12:03:15.549 Memory[67855:5668888] 0x608000260540\n2016-10-21 12:03:15.550 Memory[67855:5668888] 0xa000000000000311\n2016-10-21 12:03:15.550 Memory[67855:5668888] 0x60800005d610\n2016-10-21 12:03:15.550 Memory[67855:5668888] 0x60800000d2e0\n2016-10-21 12:03:15.550 Memory[67855:5668888] 0x608000260980\n2016-10-21 12:03:15.550 Memory[67855:5668888] 0x608000260980\n\n### 4、完全深copy\n如果想完美解决NSArray包含NSArray的情况，可以使用归档，解档的情况\n```objc\nNSMutableString *mutableString = [NSMutableString stringWithString:@\"1\"];\n// 随意创建一个包涵NSMutableString的NSMutableArray对象\nNSMutableString *mutalbeString1 = [NSMutableString stringWithString:@\"1\"];\nNSMutableArray *mutableArr = [NSMutableArray arrayWithObjects:mutalbeString1, nil];\n// 将mutableString和mutableArr放入一个新的NSArray中\nNSArray *testArr = [NSArray arrayWithObjects:mutableString, mutableArr, nil];\n// 通过归档、解档方式创建copy\nNSArray *testArrCopy = [NSKeyedUnarchiver unarchiveObjectWithData:\n                            [NSKeyedArchiver archivedDataWithRootObject:testArr]];;\n```\n\n## 关键字copy\n1. 首先分别给出copy和strong修饰的属性，以NSString举例\n```objc\n// 1、strong\n@property (nonatomic, strong) NSString *str;\n// 2、copy\n@property (nonatomic, copy) NSString *str2;\n\nNSMutableString *mutableStr = [NSMutableString stringWithFormat:@\"123\"];\nself.str = mutableStr;\nself.str2 = mutableStr;\n[mutableStr appendString:@\"456\"];\n\n// str = 123456\n// str2 = 123\nNSLog(@\"%p, %p\", mutableStr, a.name); // 地址相同\n```\n由此可见，用strong修饰的变量跟原始的对象浅拷贝，原来的元素改变会改变strong的变量，copy是深拷贝，改变不会对copy元素造成影响。\n\n2. 深浅copy对引用计数的影响\n3. 浅copy，类似strong，持有原始对象的指针，会使retainCount加一。\n深copy，会创建一个新的对象，不会对原始对象的retainCount变化。\n4.首先，MRR时代用retain修饰block会产生崩溃，因为作为属性的block在初始化时是被存放在静态区的，如果block内调用外部变量，那么block无法保留其内存，在初始化的作用域内使用并不会有什么影响，但一旦出了block的初始化作用域，就会引起崩溃。所有MRC中使用copy修饰，将block拷贝到堆上。\n其次，在ARC时代，因为ARC自动完成了对block的copy，所以修饰block用copy和strong都无所谓。\n\n\n"
    }
  ]
}