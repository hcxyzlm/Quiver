{
  "title": "NSOperation",
  "cells": [
    {
      "type": "markdown",
      "data": "# NSOperation\n\n ### 作用\n - 配合NSOperation和NSOperationQueue实现多线程\n\n### nsoperation和nsoperationqueue的使用步骤\n1. 先将需要执行的操作步骤封装到NSOperation中\n2. 将NSOperation对象添加到nsoperationqueue中\n3. 系统会自动将nsoperationqueue的NSOperation取出来执行\n\n## NSOperation\n- NSOperation是个抽象类，并不具备封装操作的能力，必须使用它的子类\n- 使用NSOperation子类的方式有3种\n    - NSInvocationOperation\n    - NSBlockOperation\n    - 继承NSOperation的子类\n- NSInvocationOperation\n- 创建:\n- -(id)initWithTarget:(id)target selector:(SEL)sel object:(id)arg;\n- 执行:\n- -(void)start;\n- 注意:默认情况下，start方法后并不会开辟新的一条线程去执行，而是在当前线程下，只有加入NSOperationQueue才会执行多线程\n\n```objc\nNSInvocationOperation *invocationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];\n// 增加到一个队列中去\n     NSOperationQueue *queue = [[NSOperationQueue alloc ] init];\n    [queue addOperation:invocationOperation];\n```\n\n### \n- NSBlockOperation\n- 创建方法\n- +(instancetype)blockOperationWithBlock:(void (^)(void))block\n- 添加额外的任务（在子线程执行）\n- addExecutionBlock,如果在并发队列也会开启新的子线程\n- \n\n1. NSOperation start方法后并不会开辟新的一条线程去执行，默认是在主线程执行，当加入NSOperationQueue的队列中，默认会开辟线程去执行\n\n```objc\nNSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^(){\n        NSLog(@\"download1, current thread = %@\", [NSThread currentThread]);\n    }];\n    \n    [op addExecutionBlock:^{\n        // 子操作， 子线程\n        NSLog(@\"downloa2, current thread = %@\", [NSThread currentThread]);\n    }];\n    [op addExecutionBlock:^{\n        // 子操作， 子线程\n        NSLog(@\"downloa3, current thread = %@\", [NSThread currentThread]);\n    }];\n    \n    NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n    [queue addOperation:op];\n```\n\n### NSOperationQueue的队列类型\n1. 主队列(+ (NSOperationQueue *)mainQueue),凡是添加到主队列，都会放到主线程中执行\n2. 其他队列(串行，并发)，[[NSOperationQueue alloc]init]，凡是添加到这种队列，就会被自动放到子线程中执行\n3. 添加到队列中，任务就会自动执行,NSOperation可以调用start方法来执行任务，但默认是同步执行的\n4. 隐式开启操作\n```objc\n[queue addOperationWithBlock:^{\n        NSLog(@\"excuse downlaod7 --->%@\", [NSThread currentThread]);\n    }];\n```\n5. 控制最大并发数maxConcurrentOperationCount\n6. 挂起队列suspended = Yes, NO为恢复\n7. 取消所有的任务cancelAllOperations，如果有任务正在执行操作，操作完成才会取消所有任务\n8. 操作依赖，使用nsoperation的addDependency设置依赖，来保证执行顺序\n9. 比如一定要让操作A执行完以后，才能执行操作B，可以这么写\n```objc\nNSOperationQueue *queue = [[NSOperationQueue alloc] init];\n    \n    self.queue = queue;\n    \n    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"task1 ---->%@\", [NSThread currentThread]);\n    }];\n    \n    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"task2 ---->%@\", [NSThread currentThread]);\n    }];\n    \n    NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"task3 ---->%@\", [NSThread currentThread]);\n    }];\n    \n    // 操作1执行前先执行操作3\n    [op1 addDependency:op3];\n    // 操作执行前先执行操作1\n    [op addDependency:op1];\n    \n    [queue addOperation:op];\n    [queue addOperation:op1];\n    [queue addOperation:op3];\n```\n注意点: 两个操作不能相互依赖，比如a依赖b,b依赖a\n\n## 操作的监听\n### 可以监听一个NSOperation执行\n1. 相关函数 NSOperation.completionBlock [NSOperation setCompletionBlock]\n ```objc\n - (void)testCompleteBlock {\n    \n    NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n    \n    self.queue = queue;\n    \n    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"task1 ---->%@\", [NSThread currentThread]);\n    }];\n    \n    op.completionBlock = ^{\n        NSLog(@\"执行完成\");\n    };\n    \n    [queue addOperation:op];\n}\n```\n\n## 自定义自己的任务操作\n1. 继承NSOperation\n2. 重写main方法\n3. 在main执行需要的任务\n\n```objc\n@implementation MyOperation\n\n- (void)main {\n    \n    [self handleStart];\n}\n\n- (void)handleStart {\n    NSLog(@\"MyOperation --->%@\", [NSThread currentThread]);\n}\n\n```"
    },
    {
      "type": "markdown",
      "data": "\n"
    },
    {
      "type": "markdown",
      "data": ""
    }
  ]
}