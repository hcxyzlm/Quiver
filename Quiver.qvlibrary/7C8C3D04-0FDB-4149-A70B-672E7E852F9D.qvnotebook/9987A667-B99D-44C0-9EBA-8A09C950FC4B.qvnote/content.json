{
  "title": "block对象模式",
  "cells": [
    {
      "type": "markdown",
      "data": "### corefondation的源码\n[corefondation的源码](https://github.com/hcxyzlm/Obj4.git \"Title\")\n\n### block的类型\n  - _NSConcreteGlobalBlock 全局的静态 block，不会访问任何外部变量\n  - _NSConcreteStackBlock 保存在栈上的block,当函数返回时会被销毁\n  - _NSConcreteMallocBlock 保存在堆中的 block，当引用计数为 0 时会被销毁\n  \n  \n### block 的对象模式\n  打开Block_private.h的头文件，里面有block的数据结构\n  \n  ```objc\n  struct Block_layout {\n    void *isa;\n    volatile int32_t flags; // contains ref count\n    int32_t reserved; \n    void (*invoke)(void *, ...);\n    struct Block_descriptor_1 *descriptor;\n    // imported variables\n};\n\n};\n\n// 参数说明\n1. isa就是所有对象一样的isa指针\n2.flags 用于按bit标示的block的附加信息\n3. reserved 保留变量，用于复制外部的数值\n4. invoke 函数指针，用户回调\n5.descriptor，表示改block的描述信息,比如size， reserved变量\n\nstruct Block_descriptor {\n    uintptr_t reserved;\n    uintptr_t size;\n    void (*copy)(void *dst, const void *src);\n    void (*dispose)(const void *);\n};\n\n  ```\n  \n  ### 使用clang 编译oc文件的命令\n  - clang -rewrite-objc block.c\n  \n## 测试\n1. 新建一个main.c的文件\n2. 编写代码如下\n\n```objc\nint main()\n{\n      void(^block)(void) = ^{ \n        printf(\"Hello, World!\\n\"); \n       };\n\n       block();\n\n   return 0;\n}\n};\n```\n3. 使用clang -rewrite-objc main.c命令生成main.cpp文件，打开后可以看到block的结构体如下\n\n```objc\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n\n        printf(\"Hello, World!\\n\");\n\n       }\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n\n```\n可以看出该blokc是一个_NSConcreteStackBlock,数据结构开始部分是一个自己的本身地址，所以block也可以看成是一个类\n\n### block对象的复制\n我们知道，在我们在block外面定义一个变量，在block内部访问这个变量，他是不会变的\n```objc\nint main()\n{\n\t    int number = 5;\n      void(^block)(void) = ^{ \n        printf(\"Hello, World!\\n\"); \n         printf(\"nubmer = %i\\n\", number);\n       };\n\n       number = 4;\n       block();\n\n   return 0;\n}\n```\n这里输出依然是5，改变number的值不会block内存的值改变，这是为什么？我们打开cpp文件。\n```objc\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  int number;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _number, int flags=0) : number(_number) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\n```\n可以看到block内部有number的成员变量，把创建blcok动作那一刻，对nubmer的值拷贝了一份到自己的结构体中，所以这就是为什么number不会发生改变的愿意\n\n### __block 变量的影响\n1. 基于上面的例子，当我们用__block修饰number时，可以看出block是会发生改变的,我们看下block的结构\n\n```objc\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __Block_byref_number_0 *number; // by ref\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_number_0 *_number, int flags=0) : number(_number->__forwarding) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\n```\n源码增加了__Block_byref_number_0的结构体，这个用来保存我们要改变的number变量，并把_number->__forwarding赋值给nubmer\n我们看下__Block_byref_number_0的数据结构\n```objc\nstruct __Block_byref_number_0 {\n  void *__isa;\n__Block_byref_number_0 *__forwarding;\n int __flags;\n int __size;\n int number;\n};\n```\n1. 可以得出block是保存__Block_byref_number_0结构体的指针，可以起到修改外部变量的作用\n2. __Block_byref_number_0里面有isa指针，所以__Block_byref_number_0也是一个对象\n3. __forwarding的指针指向自己本身，保存有nubmer的值，所以当__Block_byref_number_0发生改变时，__Block_byref_number_0的number值也会发生改变\n\n\n### _NSConcreteMallocBlock的block实现\n1. 当block被调用到其copy方法时，系统会把block赋值到堆上，而产生_NSConcreteMallocBlock的block。\n\n### 变量的复制\n1. 对于block外的变量引用，block默认是将复制其数据结构来实现访问的。如果这个对象是引用类型，block的计数器会加1，这就是为什么会发生循环引用的原因，因为一个类有block的引用，然后block也有对这个类引用，会形成一个闭环阻塞，从而造成内存泄漏。\n\n### arc对block类型的影响\n1. 在arc开启时，只有有_NSConcreteGlobalBlock 和 _NSConcreteMallocBlock两种类型的block。\n2. 原本的_NSConcreteStackBlock会变成_NSConcreteMallocBlock两种类型的block类型的来替代"
    }
  ]
}