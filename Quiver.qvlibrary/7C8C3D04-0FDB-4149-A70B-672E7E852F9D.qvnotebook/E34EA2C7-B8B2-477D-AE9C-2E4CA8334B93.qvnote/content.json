{
  "title": "类的对象模型",
  "cells": [
    {
      "type": "markdown",
      "data": "## 类的对象模型组成\n1.在runtime.h找到Class和objct的定义\n```objc\ntypedef struct objc_class *Class;\n\n/// Represents an instance of a class.\nstruct objc_object {\n    Class isa  OBJC_ISA_AVAILABILITY;\n}*id;\n```\n可以看出class 和id都是一个Class的结构体，下面让我来看下class结构体有哪些结构\n```objc\nstruct objc_class {\n    Class isa  OBJC_ISA_AVAILABILITY;\n\n#if !__OBJC2__\n    Class super_class                                        OBJC2_UNAVAILABLE;\n    const char *name                                         OBJC2_UNAVAILABLE;\n    long version                                             OBJC2_UNAVAILABLE;\n    long info                                                OBJC2_UNAVAILABLE;\n    long instance_size                                       OBJC2_UNAVAILABLE;\n    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;\n    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;\n    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;\n    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;\n#endif\n\n} OBJC2_UNAVAILABLE;\n```\n上面的可以看出class包含了两个主要的对象isa， super\n类的实例对象(instace object)指向类对象(class)。类对象(class)的isa指针指向类结构称为元类(metaclass),元类保存类的static成员变量和static方法(+开头的方法)，实例对象中的isa指向类对象(普通的class),\n该结构存储了普通成员变量与普通的成员方法(-开头的方法)。\n\n### 继承中的子类，父类，根类的关系\n  - 规则1: 类的实例对象is指向该类，该类的isa指向该类的元类(metaclass)\n  - 规则2: 类的super_class执行该类，如果该类为根类(nsobject)则值为NULL\n  - 规则3: metaclass的isa指向根类的metaclass,如果该类为根类(nsobjct)则指向本身\n  - metaclass的super_class指向父metaclass,如果该metaclass是根metaclass则指向metaclass对应的类\n  \n### 例子，child-->father-->nsobject，对象的关系图如下\n![QQ20170406-0@2x.png](quiver-image-url/FBF9536EE2738A7CA637F6775E28C49B.png)\n\n### class的结构变量\n1. objc_ivar_list *ivars 该类是class普通类保存普通成员变量，是metaclass保存类的static成员变量\n2. objc_method_list **methodLists，该类是class普通类是成员方法(-开头方法)，是metaclass类方法(方法)\n3. objc_cache *cache，用于存储最近调用的方法缓存，下次调用直接使用，不用再遍历查找\n\n\n### class的方法的重写和寻址\n1. methodLists保存了成员方法，如果该类是子类，并且重写了父类方法，重写方法会在此列表中。子类调用方法时，会在cache中查找，找到该方法的缓存，直接返回imp, 如果没找到去类的methodLists的列表找，如果能找到，返回，并加入cache，如果找不到就会往superclass的methodLists方法中寻找，往上递推。找不到就进入到动态决策，和消息转发\n\n### + (void)initialize方法调用层级\n![QQ20170407-0@2x.png](quiver-image-url/C2292C1AC31AD5C7CE041D5DE2EE7CEC.png)\n```objc\nIMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)\n{\n// 根类的id,nsojbet ，sel =alloc, cls = 自己类本身\n    return lookUpImpOrForward(cls, sel, obj, \n                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);\n}\n```\n\n### runtime的cache机制\n为了加速消息发送的进程，runtime缓存了selector和曾经使用的方法实现的映射。每个类都有自己的缓存，它能缓存selector和祖先类中的方法实现映射。在查找派发表之前，消息发送系统会先检查接收者的缓存（理论上说，用过的方法实现，不久会再用到）。如果缓存命中，则消息发送几乎和函数调用一样快。一旦程序运行时间足够长，缓存有了充足的“热身”【warm up】，那么几乎所有的查找都能在缓存中完成。随着程序的运行，缓存也会不断添加新的映射。"
    }
  ]
}