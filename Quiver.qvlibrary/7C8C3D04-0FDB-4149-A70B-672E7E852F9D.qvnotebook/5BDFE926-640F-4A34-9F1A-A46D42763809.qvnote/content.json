{
  "title": "NSRunLoop",
  "cells": [
    {
      "type": "markdown",
      "data": "### 作用\n1. 使程序一直运行接受用户输入\n2. 决定程序在何时处理哪些event\n3. 调用解耦(message queue)\n4. 节省cpu时间\n\n## NSRunLoop简介(运行循环)\n目的\n1. 保证程序不退出(主线程)\n2. 负责监听所有的事件:触摸，时钟，网络事件\n1. 相当于一个while或者for无限循环，当有输入源产生的时候，他就会处理，让你的进程不会退出，没有事件源的时候不占cup内存，在休眠\n\n3. runloop他还需要做一件事，ui绘制。在一次runloop循环中要绘制屏幕上所有需要重绘的点。\n问题:\n    tableview的cell中如果做性能优化---》加速图片的性能优化。\n    如果加载本地图片是一个耗时操作？怎么办？\n解决问题: 卡顿问题\n分析: 为什么会卡顿？一次runloop循环需要绘制所有的图片，18张高清图片。\n// 将绘制15张图片分别派发给每一次runloop循环？\n每次runloop循环加载一张图片。由于runloop循环非常快，所有加载图片不影响。\n思路: 1.监听每一次runloop的循环，c语言。\n      2.在runloop循环一次时候，拿代码执行。\n\n\n## NSRunLoop相关函数\n1.mainRunLoop，或者主的runloop，默认主线程会自动创建一个NSRunLoop，子线程不会自动创建，需要自己手动创建\n2. currentRunLoop 或者当前的runloop，主线程中相当于主的runloop，子线程调用这个函数，会新建一个runloop，他是懒加载\n```objc\nNSThread *pThread = [[NSThread alloc] initWithBlock:^{\n        NSLog(@\"CurrentRunLoop = %@\", [NSRunLoop currentRunLoop ]);\n        NSPort *port = [NSPort port];\n        port.delegate = self;\n        NSRunLoop *loop = [NSRunLoop currentRunLoop];\n        [loop addPort:port forMode:NSDefaultRunLoopMode];\n        \n    }];\n    \n    [pThread start];\n```\n3. Main函数中的RunLoop, 被称为主运行循环, 而主运行循环在整个App的声明周期中都不会被销毁, 他是程序运行的保证\n\n### app启动整个流程\n1. 执行main函数\n2. 执行UIApplicationMain函数\n3.  创建UIApplication对象，并且指定他的代理Appdelegate\n4.  创建一个事件循环：主循环(RunLoop)，并且是一个死循环，保证程序的持续运行\n5.  加载配置了所有应用程序信息的info.plist文件\n            1> 判断 Main storyboard file base name中有没有指定Main，即需要加载的StoryBoard文件\n            2> 如果指定了，就加载Main.storyboard\n            3> 如果没有指定的话，就会黑屏\n6. 应用程序启动完毕\n\n\n## CFRunLoopRef类\n1. CFRunLoopGetMain相当于mainRunLoopa\n2. CFRunLoopGetCurrent相当于currentRunLoop\n\n\n## Run Loop Modes\n1. 系统默认注册的5个Mode\n```objc\nkCFRunLoopDefaultMode: App的默认Mode, 通常主线程是在这个Mode下运行的\n\nUITrackingRunLoopMode: 界面跟踪Mode, 用于ScrollView/TableView等追踪触摸滑动, 保证界面滑动的时候不受其他Mode影响\n\nUIInitializationRunLoopMode: 当App启动时, 第一个进入的Mode, 启动完成之后就不会再使用这个Mode\n\nGSEventReceiveRunLoopMode: 接收系统事件的内部Mode, 通常由系统自动管理\n\nkCFRunLoopCommonMode: 一个类似于占位的Mode, 并不是一个真正的Mode\n```\n1. runloop运行的模式，一般有2种模式\n2. NSDefaultRunLoopMode一般模式\n3. kCFRunLoopDefaultMode，scrollview滚动模式，这个模式下NSDefaultRunLoopMode将处理不到消息，所有nstime响应不了\n\n### NSTimer的启动模式(时钟是运行在default，如果滚动的时候相应不到，因为滚动入NSRunLoopCommonModes)\n1. 新建一个NSTimer\n2. NSRunLoop加入timer，如果启动模式为NSDefaultRunLoopMode的话，在滚动scorllview的时候，定时器不起作用，需要加入NSRunLoopCommonModes模式\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSTimer *timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(handleTimer) userInfo:nil repeats:YES];\n    \n    [[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];\n}\n\n// 不要在这个地方做耗时操作，不然会卡顿UI。\n- (void) handleTimer {\n    \n    NSLog(@\"time --- \");\n    \n    [NSThread sleep:1];\n}\n\n```\n\n## Mode中的类\n1. CFRunLoopSourceRef: **事件源, 事件, 输入等都属于事件源, 他有两个分类**\n2. Source0, 非基于Port, 用户触发的事件, 例如点击事件等\nSource1, 基于Port的事件, 他用于系统内部与线程之间交互\n3. CFRunLoopTimerRef: 定时器事件\n    NSTimer\n    GCD定时器\n4. CFRunLoopObserverRef: 观察者\n5. \n\n## 三. RunLoop与线程\n1. 每一条线程, 都有一个与之相对应的RunLoop对象, 负责处理线程中的任务\n2. 线程的创建\n    主线程：RunLoop是程序已经启动好的时候就创建好了，当程序关闭的时候主线城才被销毁\n    子线程：需要自己去创建runloop，并且手动开启，当任务没有执行时，线程会被关闭，Runloop被销毁\n3.子线程和runloop的是一一对应关系，每个子线程都有自己的runloop(自己创建  )\n\n```objc\nwhile(A){\n\n[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];\n\n}\n\n当前A为YES时，当前runloop会一直接收处理其他输入源，当前流程不继续处理，出为A为NO，当前流程继续\n\n```\n\n## runloop的源码解析\n1. CFRunLoopRef相当于nsrunloop\n2. CFRunLoopSourceRef(输入源)\n3. CFRunLoopObserverRef (监听)\n4. CFRunLoopTimerRef(定时器)\n\n## 监听runloop循环\n步骤:\n1. 创建一个CFRunLoopObserverRef，观察者结构体，需要监听什么的东西\n  ```objc\n  CFRunLoopObserverRef CFRunLoopObserverCreate ( CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, CFRunLoopObserverCallBack callout, CFRunLoopObserverContext *context );\n  // 参数\n  enum CFRunLoopActivity {\n   kCFRunLoopEntry = (1 << 0),  // 进入runloop，只会调用一次\n   kCFRunLoopBeforeTimers = (1 << 1), // 处理时钟。多次调用\n   kCFRunLoopBeforeSources = (1 << 2), // 处理源\n   kCFRunLoopBeforeWaiting = (1 << 5), // 等待\n   kCFRunLoopAfterWaiting = (1 << 6), // 等待后 \n   kCFRunLoopExit = (1 << 7),         // 退出 // 调用一次\n   kCFRunLoopAllActivities = 0x0FFFFFFFU // \n};\n\nCFRunLoopObserverContext context = {\n        0,\n        ( __bridge void *)(self),\n        &CFRetain,\n        &CFRelease,\n        NULL\n    }; // 上下文\n    repeats: 是否循环\n    order: Int类型，需要监听多少次\n    callout: 监听的回调\n    context: 上下文\n  ```\n  2. 加入runloop监听\n  ```objc\n  void CFRunLoopAddObserver ( CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef mode )\n  // mode: 一般为kCFRunLoopCommonModes\n  ```\n  ```objc\n  -(void)addRunloopObserver{\n    //获取当前的RunLoop\n    CFRunLoopRef runloop = CFRunLoopGetCurrent();\n    //定义一个centext\n    CFRunLoopObserverContext context = {\n        0,\n        ( __bridge void *)(self),\n        &CFRetain,\n        &CFRelease,\n        NULL\n    };\n    //定义一个观察者\n    static CFRunLoopObserverRef defaultModeObsever;\n    //创建观察者\n    defaultModeObsever = CFRunLoopObserverCreate(NULL,\n                                                 kCFRunLoopBeforeTimers,\n                                                 YES,\n                                                 NSIntegerMax - 999,\n                                                 &Callback,\n                                                 &context\n                                                 );\n    \n    //添加当前RunLoop的观察者\n    CFRunLoopAddObserver(runloop, defaultModeObsever, kCFRunLoopDefaultMode);\n    //c语言有creat 就需要release\n    CFRelease(defaultModeObsever);\n   \n}\n  ```\n  \n  \n  ## runloop 和NSOperation的结合使用\n  解释:由于NSOperation的main函数一结束就不能响应了，就需要runloop来保持事件的触发。\n  步骤\n  1. 新建NSOperation的子类，重新start 和main 方法\n  2. 需要把当前线程的runloop的加入\n  ```objc\n  NSRunLoop *runLoop = [NSRunLoop currentRunLoop];\n        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\n        [runLoop run];\n        \n        - (void)main {\n    @autoreleasepool {\n        [self.lock lock];\n        [self performSelector:@selector(handlerStart) onThread:[[self class] operationThread] withObject:nil waitUntilDone:NO modes:self.runLoopModes];\n        [self.lock  unlock];\n    }\n}\n当有事件发生就会回调handlerStart的方法\n  ```\n  \n  \n  \n\n"
    }
  ]
}