{
  "title": "freeStream开源框架的学习",
  "cells": [
    {
      "type": "markdown",
      "data": "## audio queue server的简介\n1. AudioQueueNewOutput // 用来创建一个播放音频队列的对象AudioQueueRef，然后就是对该audioqueue对象进行操作,用来添加一个回调方法，当播放音频队列有重用的队列，会回调该方法\n\n2. 播放本地使用AudioFile来读取音乐数据，播放流媒体使用AudioFileStream来读取。"
    },
    {
      "type": "markdown",
      "data": "## 音频基础\n声波是一种机械波，是一种模拟信号。\nPCM，全称脉冲编码调制，是一种模拟信号的数字化的方法。\n采样精度（bit pre sample)，每个声音样本的采样位数。\n采样频率（sample rate）每秒钟采集多少个声音样本。\n声道（channel）：相互独立的音频信号数，单声道（mono）立体声（Stereo）\n语音帧（frame），In audio data a frame is one sample across all channels."
    },
    {
      "type": "markdown",
      "data": "## iOS 开发中对应的结构\nstruct AudioStreamBasicDescription\n{\n    Float64             mSampleRate;  // 采样频率\n    AudioFormatID       mFormatID;    // \n    AudioFormatFlags    mFormatFlags;\n    UInt32              mBytesPerPacket;\n    UInt32              mFramesPerPacket;\n    UInt32              mBytesPerFrame;\n    UInt32              mChannelsPerFrame;\n    UInt32              mBitsPerChannel;\n    UInt32              mReserved;\n};\n\n### 数据样例\n(AudioStreamBasicDescription) _format = {\n  mSampleRate = 44100 \n  mFormatID = kAudioFormatLinearPCM \n  mFormatFlags = kAudioFormatFlagIsSignedInteger | kAudioFormatFlagIsPacked \n  mBytesPerPacket = 1 \n  mFramesPerPacket = 1152 \n  mBytesPerFrame = 0 \n  mChannelsPerFrame = 2 \n  mBitsPerChannel = 0 \n  mReserved = 0 \n}\n\n## AudioFileStream学习\n作用：AudioFileStreamer是用来读取采样率、码率、时长等基本信息以及分离音频帧。\nAudioFileStreamer用在流播放中，当然不仅限于网络流，本地文件同样可以用它来读取信息和分离音频帧，只是通常用AudioFile来读取本地音频\n\nAudioFileStreamer的主要数据是文件数据，支持的文件格式有：\n\nMPEG-1 Audio Layer 3, used for .mp3 files\nMPEG-2 ADTS, used for the .aac audio data format\nAIFC\nAIFF\nCAF\nMPEG-4, used for .m4a, .mp4, and .3gp files\nNeXT\nWAVE\n\n## AudioFileStream相关函数说明\n### AudioFileStreamOpen\n作用: 初始化AudioFileStream，创建一个音频流解析器，生成一个AudioFileStream示例\n\n###函数示例\n```ojbc\nOSStatus AudioFileStreamOpen ( void *inClientData, AudioFileStream_PropertyListenerProc inPropertyListenerProc, AudioFileStream_PacketsProc inPacketsProc, AudioFileTypeID inFileTypeHint, AudioFileStreamID _Nullable *outAudioFileStream );\n参数说明:\ninClientData: 上下文，一般传(__bridge void *)self\ninPropertyListenerProc：歌曲信息解析的回调，每次解析出一个歌曲信息，都会执行一次回调\ninPacketsProc：分离帧的回调，每解析出一部分帧就会进行一次回调\ninFileTypeHint：是文件类型的提示，创建指定文件格式的音频流解析器\noutAudioFileStream：AudioFileStream实例对应的AudioFileStreamID，其他函数需要用到\n```\n\n## AudioFileStream_PacketsProc解析\n作用: 解析文件格式信息的回调，在调用AudioFileStreamParseBytes方法进行解析时会首先读取格式信息，并同步的进入AudioFileStream_PropertyListenerProc回调方法\n函数示例\n\n### AudioFileStream_PropertyListenerProc\n1.解析文件格式信息的回调，在调用AudioFileStreamParseBytes方法进行解析时会首先读取格式信息，并同步的进入AudioFileStream_PropertyListenerProc回调方法\n2.当前PropertyID对应的信息已经解析完成信息\n```objc\nextern OSStatus AudioFileStreamGetProperty(AudioFileStreamID inAudioFileStream, \n                                       AudioFileStreamPropertyID inPropertyID, \n                                       UInt32 * ioPropertyDataSize, \n                                       void * outPropertyData);\n```\nAudioFileStreamPropertyID解析\n1. kAudioFileStreamProperty_BitRate：音频数据的码率，通过码率可以计算音视频的总时长\n2. kAudioFileStreamProperty_DataOffset 表示音频数据在整个音频文件中的offset,除去头部\n因为大多数音频文件都会有一个文件头之后才使真正的音频数据），这个值在seek时会发挥比较大的作用，音频的seek并不是直接seek文件位置而seek时间（比如seek到2分10秒的位置），seek时会根据时间计算出音频数据的字节offset然后需要再加上音频数据的offset才能得到在文件中的真正offset\n3. AudioFileStreamProperty_DataFormat 表示音频文件结构信息，是一个AudioStreamBasicDescription的结构\n4. kAudioFileStreamProperty_FormatList 作用和kAudioFileStreamProperty_DataFormat是一样的，区别在于用这个PropertyID获取到是一个AudioStreamBasicDescription的数组\n5. kAudioFileStreamProperty_AudioDataByteCount 音频文件中音频数据的总量。这个Property的作用一是用来计算音频的总时长，二是可以在seek时用来计算时间对应的字节offset\n6. kAudioFileStreamProperty_ReadyToProducePackets 一旦回调中这个PropertyID出现就代表解析完成，接下来可以对音频数据进行帧分离了\n\n## AudioFileStream_PacketsProc解析\n作用: 分离音频帧回调，读取格式信息完成之后，继续调用AudioFileStreamParseBytes方法可以对帧进行分离，并同步的进入AudioFileStream_PacketsProc回调方法\n函数示例\n```objc\ntypedef void (*AudioFileStream_PacketsProc) ( void *inClientData, UInt32 inNumberBytes, UInt32 inNumberPackets, const void *inInputData, AudioStreamPacketDescription *inPacketDescriptions );\n参数说明:\ninClientData 得到上下文\ninNumberBytes 表示本次处理的数据大小\ninNumberPackets 本次总共处理了多少帧AudioFileStreamPropertyID\ninInputData 本次处理的所有数据\nAudioStreamPacketDescription AudioStreamPacketDescription数组，存储了每一帧数据是从第几个字节开始的，这一帧总共多少字节。\n```\n\n## AudioFile的学习\n1. 这个类可以用来创建、初始化音频文件；读写音频数据；对音频文件进行优化；读取和写入音频格式信息等等，功能十分强大，可见它不但可以用来支持音频播放，甚至可以用来生成音频文件。当然，在本篇文章中只会涉及一些和音频播放相关的内容（打开音频文件、读取格式信息、读取音频数据，其实我也只对这些方法有一点了解，其余的功能没用过。。>_<）.\n\n### 函数说明\n1. AudioFileOpenURL: 打开指定文件，并赋予读或写的权限\n2、 AudioFileOpenWithCallbacks\n```objc\nextern OSStatus AudioFileOpenWithCallbacks (void * inClientData,\n                                            AudioFile_ReadProc inReadFunc,\n                                            AudioFile_WriteProc inWriteFunc,\n                                            AudioFile_GetSizeProc inGetSizeFunc,\n                                            AudioFile_SetSizeProc inSetSizeFunc,\n                                            AudioFileTypeID inFileTypeHint,\n                                            AudioFileID * outAudioFile);\n```\n参数说明：\n第一个参数，上下文信息，不再多做解释；\n第二个参数，当AudioFile需要读音频数据时进行的回调（调用Open和Read方式后同步回调）；\n第三个参数，当AudioFile需要写音频数据时进行的回调（写音频文件功能时使用，暂不讨论）；\n第四个参数，当AudioFile需要用到文件的总大小时回调（调用Open和Read方式后同步回调）；\n第五个参数，当AudioFile需要设置文件的大小时回调（写音频文件功能时使用，暂不讨论）；\n第六、七个参数和返回值同AudioFileOpenURL方法；\n这个方法的重点在于AudioFile_ReadProc这个回调。换一个角度理解，这个方法相比于第一个方法自由度更高，AudioFile需要的只是一个数据源，无论是磁盘上的文件、内存里的数据甚至是网络流只要能在AudioFile需要数据时（Open和Read时）通过AudioFile_ReadProc回调为AudioFile提供合适的数据就可以了，也就是说使用方法不仅仅可以读取本地文件也可以如AudioFileStream一样以流的形式读取数据。\n\n## audiofile使用局限性\n1. udioFile的Open方法会根据文件格式类型分几步进行数据读取以解析确定是否是一个合法的文件格式，其中每一步的inPosition和requestCount都不一样，如果某一步不成功就会直接进行下一步，如果几部下来都失败了，那么Open方法就会失败。简单的说就是在调用Open之前首先需要保证音频文件的格式信息完整，这就意味着AudioFile并不能独立用于音频流的读取，在流播放时首先需要使用AudioStreamFile来得到ReadyToProducePackets标志位来保证信息完整\n\n### 读取音频格式信息\n成功打开音频文件后就可以读取其中的格式信息了，读取用到的方法如下：\n```objc\nextern OSStatus AudioFileGetPropertyInfo(AudioFileID inAudioFile,\n                                         AudioFilePropertyID inPropertyID,\n                                         UInt32 * outDataSize,\n                                         UInt32 * isWritable);\n                                      \nextern OSStatus AudioFileGetProperty(AudioFileID inAudioFile,\n                                     AudioFilePropertyID inPropertyID,\n                                     UInt32 * ioDataSize,\n                                     void * outPropertyData);   \n```\n说明:\nAudioFileGetPropertyInfo方法用来获取某个属性对应的数据的大小（outDataSize）以及该属性是否可以被write（isWritable），而AudioFileGetProperty则用来获取属性对应的数据。对于一些大小可变的属性需要先使用AudioFileGetPropertyInfo获取数据大小才能取获取数据（例如formatList），而有些确定类型单个属性则不必先调用AudioFileGetPropertyInfo直接调用AudioFileGetProperty即可（比如BitRate）\n\n### 读取音频数据(按帧（Packet）读取音频数据)\n```objc\nextern OSStatus AudioFileReadPacketData (AudioFileID inAudioFile,\n                                         Boolean inUseCache,\n                                         UInt32 * ioNumBytes,\n                                         AudioStreamPacketDescription * outPacketDescriptions,\n                                         SInt64 inStartingPacket,\n                                         UInt32 * ioNumPackets,\n                                         void * outBuffer);\n                                      \n\nextern OSStatus AudioFileReadPackets (AudioFileID inAudioFile,\n                                      Boolean inUseCache,\n                                      UInt32 * outNumBytes,\n                                      AudioStreamPacketDescription * outPacketDescriptions,\n                                      SInt64 inStartingPacket,\n                                      UInt32 * ioNumPackets,\n                                      void * outBuffer);\n                                      \n参数说明:\n只有当需要读取固定时长音频或者非压缩音频时才会用到AudioFileReadPackets，其余时候使用AudioFileReadPacketData会有更高的效率并且更省内存\n\n第一、二个参数，同AudioFileReadBytes；\n第三个参数，对于AudioFileReadPacketData来说ioNumBytes这个参数在输入输出时都要用到，在输入时表示outBuffer的size，输出时表示实际读取了多少size的数据。而对AudioFileReadPackets来说outNumBytes只在输出时使用，表示实际读取了多少size的数据；\n第四个参数，帧信息数组指针，在输入前需要分配内存，大小必须足够存在ioNumPackets个帧信息（ioNumPackets * sizeof(AudioStreamPacketDescription)）；\n第五个参数，从第几帧开始读取数据；\n第六个参数，在输入时表示需要读取多少个帧，在输出时表示实际读取了多少帧；\n第七个参数，outBuffer数据指针，在输入前就需要分配好空间，这个参数看上去两个方法一样但其实并非如此。对于AudioFileReadPacketData来说只要分配近似帧大小 * 帧数的内存空间即可，方法本身会针对给定的内存空间大小来决定最后输出多少个帧，如果空间不够会适当减少出的帧数；而对于AudioFileReadPackets来说则需要分配最大帧大小(或帧大小上界) * 帧数的内存空间才行（最大帧大小和帧大小上界的区别等下会说）；这也就是为何第三个参数一个是输入输出双向使用的，而另一个只是输出时使用的原因。就这点来说两个方法中前者在使用的过程中要比后者更省内存；\n返回值，同AudioFileReadBytes；\n```\n\n\n## audioQueueBuffer 解析\n1. audio像一个缓冲，对音频有缓存的效果\n播放流程\n1. 创建AudioQueue， 建立一个自己的buffer数组BufferArray\n2. 使用AudioQueueAllocateBuffer创建若干个AudioQueueBufferRef（一般2-3个即可），放入BufferArray\n3. 有数据时从BufferArray取出一个buffer，memcpy数据后用AudioQueueEnqueueBuffer方法把buffer插入AudioQueue中\n4. AudioQueue中存在Buffer后，调用AudioQueueStart播放。（具体等到填入多少buffer后再播放可以自己控制，只要能保证播放不间断即可）\n5. audioQueue播放音乐时后消耗某个buffer后，在另一个线程回调并送出该buffer,把buffer放回bufferArray供下一次使用。\n"
    }
  ]
}