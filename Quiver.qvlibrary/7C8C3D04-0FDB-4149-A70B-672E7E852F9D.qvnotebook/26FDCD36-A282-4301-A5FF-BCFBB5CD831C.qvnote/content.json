{
  "title": "理解oc消息传递机制",
  "cells": [
    {
      "type": "markdown",
      "data": "## 最简单的动态\nObjective-C 是一门极其动态的语言，许多东西都可以推迟到运行时决定、修改。那么到底何为动态、何为静态？我们通过一个简单的例子对比下\n```objc\n/***********  例1 静态绑定   ***********/\n#import <stdio.h>\nvoid printHello() {\n    printf(\"Hello, world!\\n\");\n}\nvoid printGoodbye() {\n    printf(\"Goodbye, world!\\n\");\n}\nvoid saySomething(int type) \n{\n    if (type == 0) {\n        printHello();\n    } else {\n        printGoodbye();\n    }\n    return 0;\n}\n/***********  例2 动态绑定   ***********/\n#import <stdio.h>\nvoid printHello() {\n    printf(\"Hello, world!\\n\");\n}\nvoid printGoodbye() {\n    printf(\"Goodbye, world!\\n\");\n}\nvoid saySomething(int type) \n{\n    void (*func)();\n    if (type == 0) {\n        func = printHello;\n    } else {\n        func = printGoodbye;\n    }\n    func();\n    return 0;\n}\n```\n\n例1的代码在编译期，编译器就已经知道了有 void printHello()、void printGoodbye() 俩函数，并且在 saySomething() 函数中，调用的函数明确，可以直接将函数名硬编码成地址，生成调用指令，这就是 静态绑定（static binding）。那么例2呢？例2的调用的是 func() 函数，而这函数实际调用的地址只能到程序运行时才能确定，这就是所谓的 **动态绑定**（dynamic binding）。动态绑定将函数调用从编译期推迟到了运行时。\n\n在 Objective-C 中，向对象传递消息，就会使用这种动态绑定机制来决定需要调用的方法，这种动态特性使得 Objective-C 成为一门真正动态的语言。\n\n### objec_msgSend 函数\nObjective-C 的方法调用通常都是下面这种形式\n\n```objc\nid returnValue = [someObject messageName:parameter];\n```\n\n这种方法调用其实就是消息传递，编译器看到这条消息会转换成一条标准的 C 语言函数调用\n\n```objc\nid returnValue = objc_msgSend(someObject,\n                              @selector(messageName:),\n                              parameter);\n```\n\n用消息传递的话来解释就是：向 ```someObject``` 对象发送了一个名叫 ```messageName``` 的消息，这个消息携带了一个叫 ```parameter``` 的参数。这里用到了一个 ```objc_msgSend``` 函数，其函数原型如下\n\n```objc\nvoid objc_msgSend(id self, SEL cmd, ...);\n```\n\n这是一个可变参数的函数，第一个参数代表消息接收者，第二个代表 SEL 类型，后面的参数就是消息传递中使用的参数。\n\n那么什么是 SEL 呢？SEL 就是代码在编译时，编译器根据方法签名来生成的一个唯一 ID。此 ID 可以用以区分不同的方法，只要 ID 一致，即看成同一个方法，ID 不同，即为不同的方法。\n\n当进行消息传递，对象在响应消息时，是通过 SEL 在 methodlist 中查找函数指针 IMP，找到后直接通过指针调用函数，这其实就是前文介绍的 **动态绑定**。若是找到对应函数就跳转到实现代码，若找不到，就沿着继承链往上查找，直到找到相应的实现代码为止。若最终还是没找到实现代码，说明当前对象无法响应此消息，接下来就会执行 消息转发 操作，以试图找到一个能响应此消息的对象。\n\n```objc\n// 获取 SEL \nSEL sel = @selector(methodName);\n// 获取 IMP\nIMP imp = methodForSelector(sel);\n```\n\n### 消息转发\n\n消息转发并不神奇，我们其实早已接触过，只是不知道而已\n\n```objc\n-[__NSCFNumber lowercaseString]:unrecognized selector sent to instance 0x87\n*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason:'-[NSCFNumber lowercaseString]:unrecognized selector sent to instance 0x87'\n```\n\n这段异常代码就是由 NSObject 的 doesNotRecognizeSelector: 方法所抛出的，异常表明：消息的接收者类型为 __NSCFNumber，无法响应 lowercaseString 消息，从而转发给 NSObject 处理。\n\n消息转发分为三大阶段\n\n  - 第一阶段先征询消息接收者所属的类，看其是否能动态添加方法，以处理当前这个无法响应的 selector，这叫做 **动态方法解析**（dynamic method resolution）。如果运行期系统（runtime system） 第一阶段执行结束，接收者就无法再以动态新增方法的手段来响应消息，进入第二阶段。\n  - 第二阶段看看有没有其他对象（**备援接收者**，replacement receiver）能处理此消息。如果有，运行期系统会把消息转发给那个对象，转发过程结束；如果没有，则启动完整的消息转发机制。\n  - 第三阶段 **完整的消息转发机制**。运行期系统会把与消息有关的全部细节都封装到 NSInvocation 对象中，再给接收者最后一次机会，令其设法解决当前还未处理的消息。\n  \n  ### 动态方法解析\n对象在收到无法响应的消息后，会调用其所属类的下列方法\n\n```objc\n/**\n *  如果尚未实现的方法是实例方法，则调用此函数\n *\n *  @param selector 未处理的方法\n *\n *  @return 返回布尔值，表示是否能新增实例方法用以处理selector\n */\n+ (BOOL)resolveInstanceMethod:(SEL)selector;\n/**\n *  如果尚未实现的方法是类方法，则调用此函数\n *\n *  @param selector 未处理的方法\n *\n *  @return 返回布尔值，表示是否能新增类方法用以处理selector\n */\n+ (BOOL)resolveClassMethod:(SEL)selector;\n```\n\n方法返回布尔类型，表示是否能新增一个方法来处理 selector，此方案通常用来实现 @dynamic 属性。\n\n```objc\n// 动态方法解析，先进行这一步\n+ (BOOL)resolveInstanceMethod:(SEL)name\n// 实例方法\n{\n    \n    NSLog(@\" >> Instance resolving %@\", NSStringFromSelector(name));\n    // MissMethod为调用的方法名\n    if (name == @selector(dynamicParserMethod)) {\n        \n        class_addMethod([self class], name, (IMP)dynamicMethodIMP, \"v@:\");\n        \n        return YES;\n        \n    }\n    \n    return [super resolveInstanceMethod:name];\n    \n}\n// 处理该类无法处理消息的方法\nvoid dynamicMethodIMP(id self, SEL _cmd) {\n    \n    NSLog(@\" >> dynamicMethodIMP\");\n    \n}\n\n```\n\n### 备援接收者\n如果无法 **动态解析**方法，运行期系统就会询问是否能将消息转给其他接收者来处理，对应的方法为\n\n```objc\n// 备援接收者的处理\n- (id)forwardingTargetForSelector:(SEL)aSelector {\n    \n    NSLog(@\" >> forwardingTargetForSelector %@\", NSStringFromSelector(aSelector));\n    \n    if (aSelector == @selector(testReceiveObject)) {\n        // 返回接受该方法的处理类\n        ReceiveObject *receiveObject = [[ReceiveObject alloc] init];\n        return receiveObject;\n        \n    }\n    \n    return [super forwardingTargetForSelector:aSelector];\n}\n\n```\n\n在对象内部，可能还有其他对象，该对象可通过此方法将能够处理 selector 的相关内部对象返回，在外界看来，就好像是该对象自己处理的似得。\n\n### 完整的消息转发机制\n\n如果前面两步都无法处理消息，就会启动完整的消息转发机制。首先创建 NSInvocation 对象，把尚未处理的那条消息有关的全部细节装在里面，在触发 NSInvocation 对象时，消息派发系统（message-dispatch system）将会把消息指派给目标对象。对应的方法为\n\n```objc\n/**\n *  消息派发系统通过此方法，将消息派发给目标对象,实现消息转发\n *\n *  @param anInvocation 之前创建的NSInvocation实例对象，用于装载有关消息的所有内容\n */\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    \n    NSLog(@\"forwardInvocation = %@\", NSStringFromSelector(anInvocation.selector));\n    \n    if (anInvocation.selector == @selector(forwardInvocationMsg)) {\n        \n        ReceiveObject *receiveObject = [[ReceiveObject alloc] init];\n        if ([receiveObject respondsToSelector:[anInvocation selector]]) {\n            [anInvocation invokeWithTarget:receiveObject];\n        }else {\n            [super forwardInvocation:anInvocation];\n        }\n    }\n    \n}\n\n// 调用forwardInvocation之前要先进行对方法进行注册\n\n- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector\n{\n    NSMethodSignature* signature = [super methodSignatureForSelector:selector];\n    if (!signature) {\n        // 注册\n         ReceiveObject *receiveObject = [[ReceiveObject alloc] init];\n        signature = [receiveObject methodSignatureForSelector:selector];\n    }\n    return signature;\n}\n\n```\n\n这个方法可以实现的很简单，通过改变调用的目标对象，使得消息在新目标对象上得以调用即可。然而这样实现的效果与 备援接收者 差不多，所以很少人会这么做。更加有用的实现方式为：在触发消息前，先以某种方式改变消息内容，比如追加另一个参数、修改 selector 等等。\n\n# 总结\n![image_note64270_1.png](quiver-image-url/85F0A589E7A0A0DEF08E8009AA319461.png)\n\n[demo地址](https://github.com/hcxyzlm/ForwardMsg \"title\")\n"
    }
  ]
}