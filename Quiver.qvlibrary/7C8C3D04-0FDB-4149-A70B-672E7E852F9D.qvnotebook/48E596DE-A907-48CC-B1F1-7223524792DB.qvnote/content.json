{
  "title": "iOS-Core-Animation-Advanced-Techniques笔记",
  "cells": [
    {
      "type": "markdown",
      "data": "## 第一章\n1. core animation的动画需要导入QuartzCore\n\n2. 新建一个calayer添加到图层中。\n```objc\n    CALayer *layer = [[CALayer alloc] init];\n    layer.frame = CGRectMake(50, 50, 100, 100);\n    layer.backgroundColor = [UIColor blueColor].CGColor;\n    \n    [self.viewLayer.layer addSublayer:layer];\n```\n\n3. 添加UIImage到calayer中\n```objc\nUIImage *image = [UIImage imageNamed:@\"git_cmd\"];\n    \nself.viewLayer.layer.contents = (__bridge id _Nullable)(image.CGImage);\n```\n4. Uivew的contentMode对应的CALyaer的contentsGravity,枚举见kCAGravityCenter\n\n### contentsScale\n如果contentsScale设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们熟知的Retina屏幕\n\n### masksToBounds相当于UIView的clipsToBounds\n### contentsRect\n默认的contentsRect是{0, 0, 1, 1}，这意味着整个寄宿图默认都是可见的，如果我们指定一个小一点的矩形，图片就会被裁剪（如图2.6）\n![0E88B309-12AC-4746-8E8E-C455C88E2C1A.png](quiver-image-url/0A904199A09ECC2F975283BBBF24F430.png)\n\n### UIView和CALayer的坐标关系\n![525353F6-830A-459B-844A-8030A23337D6.png](quiver-image-url/FCDB491E1DC30E5DA3D474EF3C0B3ADC.png)\n\n### Layer圆角\ncornerRadius  设置圆角\nmasksToBounds 裁剪子视图\n边框          borderWidth\n\n### 动画的混合变化\n1. 如果做一个既要缩放又要旋转的变换，这就会非常有用了。例如下面几个函数\n2. 创建一个CGAffineTransform的变量，他会自己叠加上去\n```objc\n- (void)testRotation {\n    \n    // 初始化一个矩阵\n    CGAffineTransform transform = CGAffineTransformIdentity; //create a new transform\n    transform = CGAffineTransformScale(transform, 0.5, 0.5); //scale by 50%\n    transform = CGAffineTransformRotate(transform, M_PI / 180.0 * 30.0); //rotate by 30 degrees\n    transform = CGAffineTransformTranslate(transform, 200, 0); //translate by 200 points\n    \n    self.greenView.layer.affineTransform = transform;赋值\n}\n```\n\n###CGAffineTransform的详解\n这个类是数据结构\nstruct CGAffineTransform {\n  CGFloat a, b, c, d;\n  CGFloat tx, ty;\n};\n相当于一个矩阵，2d转化是[x,y,1]。\n所以转换的时候就变成这样\n![7FD3F4F3-0D59-463F-A76C-85AD23587C29.png](quiver-image-url/C3151735DB6FFD74E26DB55E59748F26.png)\n结果为:x' = ax + cy + 1*tx;\n       y' = bx + dy + 1 *ty; \n       \n       \n### CATransform3DMakeRotation转换\nCATransform3D transform = CATransform3DIdentity;// 创建3dTransform\n\n### CATransform3D的数据结构\nstruct CATransform3D\n{\n  CGFloat m11, m12, m13, m14;\n  CGFloat m21, m22, m23, m24;\n  CGFloat m31, m32, m33, m34;\n  CGFloat m41, m42, m43, m44;\n};\ncalyer的tranform的直接赋值。\n\n### 视图的投影透视\nCATransform3D的m34可以设置透视效果\n\n### sublayerTransform 的作用，父layer设置了，子layer都会产生作用。\n\n### CALayer有一个叫做doubleSided的属性来控制图层的背面是否要被绘制。这是一个BOOL类型，默认为YES，如果设置为NO，那么当图层正面从相机视角消失的时候，它将不会被绘制\n\n### 光亮和阴影\n// 引用GLKit库\n\n### 颜色渐变层\nCAGradientLayer\n\n## uitableview 和 uiscrollview等价CAScrollLayer\n\n### CATiledLayer可以把很多小图合成在一起\n\n### CAEmitterLayer粒子效果\n\n### AVPlayerLayer\n\n\n## 显式动画\n                                   CAAnimation(父类，抽象)           \n       |                                    |                       |\n       |                                    |                       |\n       CAPropertyAnimation(属性动画)     CAAnimationGroup(组动画)   CATransition(转场动画)\n       |                            |\n       |                            |\n       CABasicAnimation(属性动画)   CAKeyframeAnimation(关键帧动画)\n\n\n### 缓冲\n1. 动画速度  velocity = change / time\n2. 缓冲CAMediaTimingFunction，可以让一个动画执行速度由快到慢，不同的速率来执行\n3. 用法:1. 设置CAAnimation的timingFunction属性，新建一个CAMediaTimingFunction对象\n4. 直接调用timingFunctionWithName的构造函数，参数如下:\n```obj\nkCAMediaTimingFunctionLinear    // 线性执行，匀速\nkCAMediaTimingFunctionEaseIn    //越来越快\nkCAMediaTimingFunctionEaseOut   // 越来越慢\nkCAMediaTimingFunctionEaseInEaseOut // 慢-->快-->慢\nkCAMediaTimingFunctionDefault      // 默认kCAMediaTimingFunctionEaseInEaseOut类似效果 \n```\n### CAKeyframeAnimation帧动画可以设置多个缓冲\n\n### UIView的动画缓冲\n设置UIViewoptions属性来设置缓冲\n\n### NSCache来做缓存\n"
    }
  ]
}