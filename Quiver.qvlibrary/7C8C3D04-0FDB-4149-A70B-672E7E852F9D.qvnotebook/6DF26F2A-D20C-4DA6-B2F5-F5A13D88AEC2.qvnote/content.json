{
  "title": "runtime的学习总结",
  "cells": [
    {
      "type": "markdown",
      "data": "##什么是runtime？\n\n1. runtime是oc语言底层的一套c的api，编译器最终将oc代码转化为运行时代码，通过编译命令编译.m文件:clang -rewrite-objc xxx.m可以看到编译后的xxx.cpp（C++文件）。\n2. 比如我们创建了一个对象 [[NSObject alloc]init]，最终被转换为几万行代码，截取最关键的一句可以看到底层是通过runtime创建的对象\n3. 如下图所示:\n4. ![8853C43C-EDD3-4559-8EAA-C9FB3FBBB902.png](quiver-image-url/83C28CC71246198795E5B2BD00634D2B.png)\n5. 可以看出，调用方法的本质就是发消息，[[NSObject alloc]init]的语句发送了两次信息，一次是发送alloc信息，第二次发送init的消息。利用这个功能可以探究底层，比如block的原理。通过objc_msgSend函数发送消息\n  \n\n## runtime的作用 （利用runtime 可以做一些OC不容易实现的功能）\n1. 动态交换两个方法的实现(特别是系统自带的方法)\n2. 动态添加对象的成员变量和成员方法\n3. 获得某个类的所有成员方法，所有成员变量\n\n## 如何应用运行时\n1. 将某些OC代码转为运行时代码，探究底层，比如block的实现原理（上边已讲到）\n2. 拦截系统自带的方法调用（Swizzle 黑魔法），比如拦截imageName:, viewDidLoad, alloc\n3. 实现分类也可以增加属性\n4. 实现NSCoding的自动归档和自动接档\n5. 实现字典和模型的自动转换\n\n## 例子\n###一. 交换两个方法的实现，拦截系统自带的方法调用功能\n需要用到的方法\n1.获得某个类的类方法\nMethod class_getClassMethod(Class aClass, SEL aSelector)\n2.获得某个类的实例方法Method class_getInstanceMethod(Class aClass, SEL aSelector)\n3.交换两个方法的实现\nOBJC_EXPORT void method_exchangeImplementations(Method m1, Method m2)\n\n1. 交换类方法\n```objc\n@implementation Person\n+ (void)run {\n    \n    NSLog(@\"run\");\n}\n\n+ (void)sleep {\n    NSLog(@\"sleep\");\n}\n@end\n\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        \n        // 通过runtime交换两个类方法\n        Method  runMethod = class_getClassMethod([Person class], @selector(run));\n        Method  sleepMethod = class_getClassMethod([Person class], @selector(sleep));\n        \n        method_exchangeImplementations(runMethod, sleepMethod);\n        \n        [Person run];\n        [Person sleep];\n        \n    }\n    return 0;\n}\n```\n\n案例2：拦截系统方法\n需求：比如iOS6 升级 iOS7 后需要版本适配，根据不同系统使用不同样式图片（拟物化和扁平化），如何通过不去手动一个个修改每个UIImage的imageNamed：方法就可以实现为该方法中加入版本判断语句？\n实现步骤:\n1. 为UIImage建一个分类UIImage+Category\n2. 在分类中实现一个自定义方法，方法中写要在系统方法中加入的语句，比如版本判断\n```objc\n+ (UIImage *)xh_imageNamed:(NSString *)name {\n    double version = [[UIDevice currentDevice].systemVersion doubleValue];\n    if (version >= 7.0) {\n        // 如果系统版本是7.0以上，使用另外一套文件名结尾是‘_os7’的扁平化图片\n        name = [name stringByAppendingString:@\"_os7\"];\n    }\n    return [UIImage xh_imageNamed:name];\n}\n```\n3. 在分类中load类方法中，实现方法的交换(只要能让执行一次交换语句，load最合适不过)\n```objc\n+ (void)load {\n    // 获取两个类的类方法\n    Method m1 = class_getClassMethod([UIImage class], @selector(imageNamed:));\n    Method m2 = class_getClassMethod([UIImage class], @selector(xh_imageNamed:));\n    // 开始交换方法实现\n    method_exchangeImplementations(m1, m2);\n}\n注意：自定义方法中最后一定要再调用一下系统的方法，让其有加载图片的功能，但是由于方法交换，系统的方法名已经变成了我们自定义的方法名（有点绕，就是用我们的名字能调用系统的方法，用系统的名字能调用我们的方法），这就实现了系统方法的拦截！\n\n利用以上思路，我们还可以给 NSObject 添加分类，统计创建了多少个对象，给控制器添加分类，统计有创建了多少个控制器，特别是公司需求总变的时候，在一些原有控件或模块上添加一个功能，建议使用该方法！\n```\n\n二、在分类中设置属性，给任何一个对象设置属性\n1. 分类是无法添加属性的，但是可以通过runtime的机制来实现这个功能。\n步骤：\n  1.添加一个分类,添加一个属性@property (nonatomic, strong) protry *protryName; \n  2. set方法，OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)\n  3. get方法id objc_getAssociatedObject(id object, const void *key)\n  \n在.m 中重写set 和 get 方法，内部利用runtime 给属性赋值和取值\n```objc\nchar nameKey;\n \n- (void)setName:(NSString *)name {\n    // 将某个值跟某个对象关联起来，将某个值存储到某个对象中\n    objc_setAssociatedObject(self, &nameKey, name, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n \n- (NSString *)name {\n    return objc_getAssociatedObject(self, &nameKey);\n}\n```\n\n三、获得一个类的所有成员变量\n最典型的做法就是一个对象在归档和解档encodeWithCoder和initWithCoder: 方法中需要该对方所有的属性进行decodeObjectForKey和encodeObject:，通过runtime我们声明中无论写多少个属性，都不需要修改实现中的代码\n用到的方法:\n1. 获取某个类的所有属性Ivar * class_copyIvarList(Class cls, unsigned int *outCount)\n2. 获得成员变量的名字 const char *ivar_getName(Ivar v)\n3.获得成员变量的类型 const char *ivar_getTypeEndcoding(Ivar v)\n4. typedef struct objc_ivar *Ivar; // 成员变量\n\n```objc\n// 获取person的所有属性\n        unsigned int count = 0;\n        Ivar *var = class_copyIvarList([Person class], &count);\n        \n        // 遍历打印属性的name和type\n        for (int i = 0; i < count; i++) {\n            NSLog(@\"name = %s, type = %s\", ivar_getName(var[i]),ivar_getTypeEncoding(var[i]));\n        }\n\n```\n\n\n## cfhttpref的使用\n1. 作用可以用来读取http的流数据，支持http格式\n```objc\n// 创建线程\n- (void)testDownLoad {\n    \n    NSURL *url = [NSURL URLWithString:downloadUrl];\n    \n    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(downLoadWithUrl:) object:url];\n    \n    [thread start];\n}\n\n-(void)downLoadWithUrl:(NSURL *)url {\n    \n    // 创建一个httPrest\n    CFHTTPMessageRef httpRef;\n    httpRef = CFHTTPMessageCreateRequest(kCFAllocatorDefault, (__bridge CFStringRef _Nonnull)(@\"GET\"), (__bridge CFURLRef _Nonnull)(url), kCFHTTPVersion1_0);\n    \n    if (!httpRef) {\n        NSLog(@\"CFHTTPMessageCreateRequest error\");\n    }\n    \n    // 创建读取流\n    CFReadStreamRef readStramRef;\n    readStramRef = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, httpRef);\n    \n    if (!readStramRef) {\n        NSLog(@\"CFReadStreamCreateForHTTPRequest error\");\n    }\n    \n    \n    if (!CFReadStreamOpen(readStramRef)) {\n        NSLog(@\"CFReadStreamOpen error\");\n    }\n    \n    CFStreamClientContext context = {0, (__bridge void*)self, NULL, NULL, NULL};\n    \n    // 让读取进入异步方式\n    CFOptionFlags flag = kCFStreamEventOpenCompleted | kCFStreamEventHasBytesAvailable | kCFStreamEventEndEncountered | kCFStreamEventErrorOccurred;\n    \n    // 数据返回会回调到readStreamClientCallBack函数中\n    if (CFReadStreamSetClient(readStramRef, flag, readStreamClientCallBack, &context) ) {\n        CFReadStreamScheduleWithRunLoop(readStramRef, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);\n    }\n    \n    \n    CFErrorRef errorRef = CFReadStreamCopyError (readStramRef);\n    if (errorRef) {\n        NSLog(@\"copy error\");\n        \n        CFRelease(errorRef);\n    }\n    \n//    CFReadStreamUnscheduleFromRunLoop(readStramRef, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);\n//    CFReadStreamClose(readStramRef);\n    // 启动\n    CFRunLoopRun();\n}\n\n// 读取处理\nstatic void readStreamClientCallBack(CFReadStreamRef stream, CFStreamEventType type, void *clientCallBackInfo) {\n    \n    NSLog(@\"type = %zd,clientCallBackInfo= %@\", type, clientCallBackInfo);\n    \n    ViewController * controller = (__bridge ViewController *)clientCallBackInfo;\n    \n    switch(type) {\n        case kCFStreamEventHasBytesAvailable: {\n            // Read bytes until there are no more\n            //\n            while (CFReadStreamHasBytesAvailable(stream)) {\n                UInt8 buffer[1024];\n                NSInteger numBytesRead = CFReadStreamRead(stream, buffer, 1024);\n                NSLog(@\"buffer = %s\", buffer);\n                \n                [controller didReceiveData:[NSData dataWithBytes:buffer length:numBytesRead]];\n            }\n            \n            \n            \n            break;\n        }\n            \n        case kCFStreamEventErrorOccurred: {\n            CFErrorRef error = CFReadStreamCopyError(stream);\n            if (error != NULL) {\n                if (CFErrorGetCode(error) != 0) {\n                    NSString * errorInfo = [NSString stringWithFormat:@\"Failed while reading stream; error '%@' (code %ld)\", (__bridge NSString*)CFErrorGetDomain(error), CFErrorGetCode(error)];\n                    \n                }\n                \n                CFRelease(error);\n            }\n        }\n             break;\n        case kCFStreamEventEndEncountered:\n            CFReadStreamClose(stream);\n            CFReadStreamUnscheduleFromRunLoop(stream, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);\n            CFRunLoopStop(CFRunLoopGetCurrent());\n            CFRelease(stream);\n            \n            [controller.fileHandle closeFile];\n            break;\n            \n        default:\n            break;\n    }\n\n}\n```\n\n## runtime的便利函数\n1. class 返回对象的类\n2. isKindOfClass 和 isMemberOfClass 检查对象是否在指定的类继承体系中\n3. respondsToSelector 检查对象能否相应指定的消息\n4. conformsToProtocol 检查对象是否实现了指定协议类的方法\n5. methodForSelector 返回指定方法实现的地址\n6. performSelector:withObject 执行 SEL 所指代的方法\n\n## 消息的转发\n场景1.\n有个类targetObject 可以接受一个消息的negotiate，并作出相应的实现。类someObject包含类targetObject\n，我们可以实现someObject中实现消息的转发\n```objc\n- negotiate\n\n{\n\nif ([someOtherObject respondsToSelector:@selector(negotiate)])\n\nreturn [someOtherObject negotiate];\n\nreturn self;\n\n}\n```\n这种方式显得有欠灵活，特别是有很多消息都希望传递给其它对象时,我们必须为每一种消息提供方法实现。\nforwardInvocation消息可以处理这种情况，来实现转发消息。\nforwardInvocation是类NSObject的方法，可以重写，改方法必须做的有\n1.决定将消息转发给谁，并且把消息和原来的参数一块转发出去\n```objc\n- (void) forwardInvocation:(NSInvocation *)anInvocation\n\n{\n\nif ([someOtherObject respondsToSelector:[anInvocation selector]])\n\n[anInvocation invokeWithTarget:someOtherObject];\n\nelse\n\n[super forwardInvocation:anInvocation];\n\n}\n注意： forwardInvocation:方法只有在消息接收对象中无法正常响应消息时才会被调用。 所以，如果我们\n\n希望一个对象将 negotiate 消息转发给其它对象，则这个对象不能有 negotiate 方法，也不能在动态方法\n\n决议过程中为之提供实现。否则，forwardInvocation:将不可能会被调用。\n```\n\n\n## 动态方法决议\n1. 当一个对象调用一个方法时，如果该方法没有实现，就会崩溃掉。\n2. 奔溃信息为unrecognized selector sent to instance 0x10010c840\n3. 解决办法：\n我们可以为该类提供一种名为动态方法的决议，使改类在运行时无法处理该消息主动跳到改方法中。\n该类有类方法和实例方法两种\n```objc\n+ (BOOL)resolveClassMethod:(SEL)name;\n\n+ (BOOL)resolveInstanceMethod:(SEL)name;\n```\n具体代码如下图所示\n```objc\n+ (BOOL)resolveInstanceMethod:(SEL)name\n// 实例方法\n{\n\nNSLog(@\" >> Instance resolving %@\", NSStringFromSelector(name));\n// MissMethod为调用的方法名\nif (name == @selector(MissMethod)) {\n\nclass_addMethod([self class], name, (IMP)dynamicMethodIMP, \"v@:\");\n\nreturn YES;\n\n}\n\nreturn [super resolveInstanceMethod:name];\n\n}\n// 处理该类无法处理消息的方法\nvoid dynamicMethodIMP(id self, SEL _cmd) {\n\nNSLog(@\" >> dynamicMethodIMP\");\n\n}\n// 类方法\n+ (BOOL)resolveClassMethod:(SEL)name\n\n{\n\nNSLog(@\" >> Class resolving %@\", NSStringFromSelector(name));\n\nreturn [super resolveClassMethod:name];\n\n}\n```\n如果该类的实例调用MissMethod方法，并且没有实现该方法，会在resolveInstanceMethod方法中处理，并添加一个dynamicMethodIMP来处理改消息。\n如果resolveInstanceMethod和resolveClassMethod返回YES，并且没有提供新的方法，也会crash。\n\n## 总结\n动态方法决议是先于消息转发的，如果向一个object-c的对象\n\n\n### kvo的runtime\n``objc\n)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context\n参数 observer:属性观察者，当keypath的值发现变化时，会回调observer的observeValueForKeyPath方法\n\n## 手动实现键值观察\n1.重写set方法，并在操作前后分别调用willChangeValueForKey和用 willChangeValueForKey: 和 didChangeValueForKey 方法，这两个方法用于通知系统该key的属性值即将改变。\n2.实现automaticallyNotifiesObserversForKey，并设置对应的keypath返回NO，不主动发送通知。\n\n``\n### kvo 底层实现原理\n1. 运行时他会创建一个NSKvoNotifion_类名的，继承被监听者的子类。\n2. 重写set方法，分别调用willChangeValueForKey 和didChangeValueForKey方法。\n\n\n### runtime 的消息机制\n1. 当我们调用方法的时候，底层都会转变成objc_msgSend(对象，方法名，参数)这种方式。\n2. 定义一个main.m文件，NSObject *object = [NSObject alloc] init];\n3. 最终的代码会变成\n4. NSObject *newObject = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)\n        ((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSObject\"), sel_registerName(\"alloc\")), sel_registerName(\"init\"));\n发送了alloc 和init的消息。\n\n## 使用objc_msgSend来调用方法\n1. performSelector调用方法，方法没有声明和实现会崩溃\n2. 对象调用method的如果有声明，没有实现也会崩溃\n3. 找不到调用的方法都会跳转到resolveInstanceMethod类方法中\n\n// 常用的方法调用\n```objc\nLMPerson *person = [[LMPerson alloc] init];\n    [person run];\n    [person performSelector:@selector(run)];\n```\n// runtime方法调用\n// 报错，苹果5.0后不建议你使用底层的调用，使用运行时\n objc_msgSend(person, @selector(run));\n // 解决方法:\n 1. 在build setting 的 ENABLE_STRICT_OBJC_MSGSEND 设置为NO\n \n ## 方法懒加载\nperform的方式使用懒加载\n[person performSelector:@selector(eat)]; \n\n## 案例 （为分类添加一个属性）\n1.定义一个字符串 static char kCustomNavBar;不需要设置字符串的值\n2.重写set/get方法\n3. set方法objc_setAssociatedObject(self, &kCustomNavBar, navigationBar, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n4. 重写get方法\n5. OBJC_EXPORT id objc_getAssociatedObject(id object, const void *key)\n\n\n## allowsWeakReference 和 retainWeakReference的作用\n1.当赋值给__weak 修饰符的变量时，retainWeakReference的作用,改变量为空\n\n```objc\n@implementation MyObject\n\n{\n    NSInteger count;\n}\n\n- (instancetype)init {\n    self = [super init];\n    return self;\n}\n\n- (BOOL)retainWeakReference {\n    \n    if (++count > 3) {\n        return NO;\n    }\n    \n    return  [super retainWeakReference];\n}\n\n id __strong obj5 = [[MyObject alloc] init];\n        id __weak o = obj5;\n        NSLog(@\"1 %@\", o);\n        NSLog(@\"2 %@\", o);\n        NSLog(@\"3 %@\", o);\n        NSLog(@\"4 %@\", o);\n        NSLog(@\"5 %@\", o);\n\n@end\n\n// 输出结果\n1 <MyObject: 0x100400160>\n2017-03-26 13:50:32.123773 内存管理释放时机[928:311226] 2 <MyObject: 0x100400160>\n2017-03-26 13:50:33.093204 内存管理释放时机[928:311226] 3 <MyObject: 0x100400160>\n2017-03-26 13:50:34.792472 内存管理释放时机[928:311226] 4 (null)\n2017-03-26 13:50:35.806978 内存管理释放时机[928:311226] 5 (null)\n\n```\n\n### allowsWeakReference 方法返回NO,程序崩溃\n```\nCannot form weak reference to instance (0x100402300) of class MyObject. It is possible that this object was over-released, or is in the process of deallocation.\nProgram ended with exit code: 9\n```\n\n## _objc_rootRetainCount 可以获取引用计数\n\n\n\n\n\n"
    }
  ]
}