{
  "title": "NSCache源码分析",
  "cells": [
    {
      "type": "markdown",
      "data": "NSCache的源码并不多，可以学习Foundation的编码风格。\n\n### NSCache和NSDictionary的\n共同点：\n1. 都是基于key-value的存储\n2. 都是容器类\n\n不同点：\n1. NSCache是线程安全的，NSDictionary不是\n2. NSCache有管理缓存的策略，当系统资源将要耗尽时，它可以自动删减缓存\n\n### 初始化\nimageCache = [[NSCache alloc] init];\n\n### 公开的属性\n```obj\n\n- (NSUInteger) countLimit; // 缓存的个数\n- (NSUInteger) totalCostLimit; // 缓存的最大分配字节\n- (id) delegate;               // 代理\n- (BOOL) evictsObjectsWithDiscardedContent; // 存储nsobject类，类是否要实现NSDiscardableContent协议\n- (NSString*) name;  // 可以设置特定的名字\n```\n\n### 私有属性\n```objc\nNSUInteger _costLimit;\n  NSUInteger _totalCost;\n  NSUInteger _countLimit;\n  id _delegate;\n  BOOL _evictsObjectsWithDiscardedContent;\n  NSString *_name;\n  NSMapTable *_objects;\n  GS_GENERIC_CLASS(NSMutableArray, ValT) *_accesses; // LRU的管理内存策略\n  int64_t _totalAccesses;\n```\n\n可以看出底层是基于NSMapTable实现key-value的方式,NSMapTable也是NSDictionary底层实现\n\n查看m文件，里面有个_GSCachedObject的私有类\n```objc\n@interface _GSCachedObject : NSObject\n{\n  @public\n  id object;\n  NSString *key;\n  int accessCount;\n  NSUInteger cost;\n  BOOL isEvictable;\n}\n```\n\n可见 _GSCachedObject 就是对“键值对”的封装，因为缓存对象有重要性的分别，自然有 cost 作为表示\n\n### 添加\n```objc\n- (void) setObject: (id)obj forKey: (id)key cost: (NSUInteger)num\n{\n// 先查出旧值\n  _GSCachedObject *oldObject = [_objects objectForKey: key];\n  _GSCachedObject *newObject;\n\n  if (nil != oldObject)\n    {\n     // 删除旧值\n      [self removeObjectForKey: oldObject->key];\n    }\n  [self _evictObjectsToMakeSpaceForObjectWithCost: num];\n  \n  // 新建_GSCachedObject\n  newObject = [_GSCachedObject new];\n  // Retained here, released when obj is dealloc'd\n  \n  // key, value赋值\n  newObject->object = RETAIN(obj);\n  newObject->key = RETAIN(key);\n  newObject->cost = num;\n  if ([obj conformsToProtocol: @protocol(NSDiscardableContent)])\n    {\n      newObject->isEvictable = YES;\n      [_accesses addObject: newObject];\n    }\n    \n  // 这个是存储obj真正的地方\n  [_objects setObject: newObject forKey: key];\n  RELEASE(newObject);\n  _totalCost += num;\n}\n```\n\n### 访问\n```objc\n- (id) objectForKey: (id)key\n{\n// 访问key\n  _GSCachedObject *obj = [_objects objectForKey: key];\n\n  if (nil == obj)\n    {\n      return nil;\n    }\n  if (obj->isEvictable)\n    {\n      // Move the object to the end of the access list.\n      [_accesses removeObjectIdenticalTo: obj];\n      [_accesses addObject: obj];\n    }\n  obj->accessCount++;\n  _totalAccesses++;\n  return obj->object;\n}\n```\n\n### 删除\n```objc\n- (void) removeObjectForKey: (id)key\n{\n  _GSCachedObject *obj = [_objects objectForKey: key];\n\n  if (nil != obj)\n    {\n      [_delegate cache: self willEvictObject: obj->object]; // delegate\n      _totalAccesses -= obj->accessCount;\n      [_objects removeObjectForKey: key];  //删除\n      [_accesses removeObjectIdenticalTo: obj];\n    }\n}\n```\n\n### 删除所有\n```objc\n- (void) removeAllObjects\n{\n// 拿到迭代器\n  NSEnumerator *e = [_objects objectEnumerator];\n  _GSCachedObject *obj;\n\n  while (nil != (obj = [e nextObject]))\n    {\n      [_delegate cache: self willEvictObject: obj->object];\n    }\n  [_objects removeAllObjects];\n  [_accesses removeAllObjects];\n  _totalAccesses = 0;\n}\n```\n\n以上是个人的粗浅理解，如有错漏，欢迎指正！"
    }
  ]
}