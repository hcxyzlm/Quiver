{
  "title": "ios沙盒机制",
  "cells": [
    {
      "type": "markdown",
      "data": "## 简介\n1. 每一个app的沙盒路径是相互独立的，别的app是无法进行访问的，因为沙盒是安全的\n2. 沙盒路径的获取\n``` objc\n// 获取程序的沙盒路径\n- (NSString *)getHomePath {\n    NSString *homePath = NSHomeDirectory();\n    NSLog(@\"homePath = %@\", homePath);\n    \n    return homePath;\n}\n```\n\n## 沙盒路径的构成\n1. Documents: 应用中用户数据可以放在这里，iTunes备份和恢复的时候会包括此目录\n2. 获取方法\n```objc\n- (NSString *)getDocumentPath {\n    \n    NSString *path =  [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];\n    NSLog(@\"document path = %@\", path);\n    \n    return path;\n}\n```\n3. tmp: 临时路径，iTunes不会备份和恢复此目录，此目录下文件可能会在应用退出后删除\n4. 获取方法\n```objc\n// 获取tmp的路径\n- (void)getTmpPath {\n    NSString *tmpPath =  NSTemporaryDirectory();\n    NSLog(@\"tmp path = %@\", tmpPath);\n}\n```\n5. Library/Caches: 存放缓存路径，下载缓存一般在这里，iTunes不会备份此目录，此目录下文件不会在应用退出删除，, 用NSUserDefaults来保存的键值对一般保存在Library/Preferences目录下\n6. 获取方法\n```objc\n- (NSString *)getCachePath {\n    \n    NSString *path =  [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject];\n    NSLog(@\"cache path = %@\", path);\n    \n    return path;\n}\n```\n\n## NSString有关的路径处理函数\n```objc\n// NSString类的路径处理函数\n- (void)parsePath {\n    \n    NSString *path = @\"/data/Containers/Data/Application/test.png\";\n    \n    // 路径的组成部分\n    NSArray *compontents = [path pathComponents];\n    NSLog(@\"components = %@\", compontents);\n    \n    // 获取文件名\n    NSString *lastName = [path lastPathComponent];\n    NSLog(@\"文件名%@\", lastName);\n    \n    // 获取文件的路径\n    NSString *componentsPath = [path stringByDeletingLastPathComponent];\n    NSLog(@\"文件路径%@\", componentsPath);\n    \n    // 路径添加文件 test.txt\n    NSString *addPath = [componentsPath stringByAppendingPathComponent:@\"test.file\"];\n    NSLog(@\"添加的文件路径名%@\", addPath);\n}\n\n```\n\n4. 写文件一般是用NSdata来写的\n```objc\n- (void)writeData {\n     NSString *path =  [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];\n    \n    path = [path stringByAppendingPathComponent:@\"myfile.txt\"];\n    \n    NSString *content=@\"write data into myFile\";\n    NSData *data = [content dataUsingEncoding:NSASCIIStringEncoding];\n    \n    BOOL ret = [data writeToFile:path atomically:YES];\n    if (ret) {\n        NSLog(@\"写入成功\");\n    }\n    \n}\n```\n\n## NSData转换函数\n```objc\n- (void)dataChange:(NSData *)data {\n    // NSData-->NString\n    NSString *aString = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n    \n    // NSSring --> data\n    NSData *aData = [aString dataUsingEncoding:NSUTF8StringEncoding];\n    \n    // NSData --> Image\n    UIImage *image = [UIImage imageWithData:aData];\n    \n    // UIImage -->NSData\n    NSData *data2 = UIImagePNGRepresentation(image);\n}\n```\n"
    },
    {
      "type": "markdown",
      "data": "## NSFileManager只文件操作\n1. 创建文件夹\n```objc\n- (void)createDirction {\n    \n    NSString *documentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];\n    \n    NSString *path = [documentPath stringByAppendingPathComponent:@\"慕课网\"];\n    \n    NSFileManager *fileManager =  [NSFileManager defaultManager];\n    if (![fileManager fileExistsAtPath:path]) {\n       BOOL succes =  [fileManager createDirectoryAtPath:path withIntermediateDirectories:YES attributes:nil error:nil];\n        \n        if (succes) {\n            NSLog(@\"创建文件夹成功\");\n            NSLog(@\"%@\", path);\n        }\n    }\n}\n```\n2. 创建文件\n```objc\n BOOL succes =  [fileManager createFileAtPath:path contents:nil attributes:nil];\n ```\n 3. 删除文件夹\n ```objc\n  BOOL succes =  [fileManager removeItemAtPath:path error:nil];\n ```\n 4. 写入文件内容(写文件一般是用NSdata来写的)\n 5. 追加文件\n ```objc\n -(void)appendContents {\n    \n    NSString *documentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];\n    \n    NSString *path = [documentPath stringByAppendingPathComponent:@\"慕课网/我的文件.txt\"];\n    \n    NSFileManager *fileManager =  [NSFileManager defaultManager];\n    if ([fileManager fileExistsAtPath:path]) {\n        [fileManager createFileAtPath:path contents:nil attributes:nil];\n    }\n    \n    NSString *str = @\"测试的内容...\";\n    NSData *data = [str dataUsingEncoding:NSUTF8StringEncoding];\n   BOOL ret =  [data writeToFile:path atomically:YES];\n    \n    if (ret) {\n        NSLog(@\"写入内容成功\");\n    }\n    \n    // 更新文件\n    [NSFileHandle fileHandleForUpdatingAtPath:path];\n    // 追加内容到文件中\n    NSFileHandle *handle = [NSFileHandle fileHandleForWritingAtPath:path];\n    // 追加到文件尾\n    [handle seekToEndOfFile];\n    \n    str = @\"追加到文件中测试内容\";\n    NSData *data2 = [str dataUsingEncoding:NSUTF8StringEncoding];\n    [handle writeData:data2];\n    \n    // 关闭句柄\n    [handle closeFile];\n    \n}\n ```\n "
    },
    {
      "type": "markdown",
      "data": "## 实际操作(写入文件和读取文件)\n1. 写入文件\n```objc\n- (void)wiriteImage {\n    \n    UIImage *image = [UIImage imageNamed:@\"text\"];\n    \n    // png格式图片解码，jpg格式用UIImageJPEGRepresentation\n   NSData *data = UIImagePNGRepresentation(image);\n    NSString *documentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];\n    \n    NSString *path = [documentPath stringByAppendingPathComponent:@\"慕课网/图片\"];\n    \n    [[NSFileManager defaultManager] createFileAtPath:path contents:nil attributes:nil];\n    \n    // 输出流\n    NSOutputStream *outStream = [NSOutputStream outputStreamToFileAtPath:path append:YES];\n    [outStream open];\n    \n   NSInteger ret =  [outStream write:data.bytes maxLength:data.length];\n    if (ret > 0) {\n        NSLog(@\"图片写入成功\");\n    }\n    \n    [outStream close];\n}\n```\n\n2. 读取图片并展示(使用nsintput)\n```objc\n// 读取文件并展示\n- (IBAction)showImage:(id)sender {\n    NSString *documentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];\n    \n    NSString *path = [documentPath stringByAppendingPathComponent:@\"慕课网/图片\"];\n    \n    NSInputStream *inputStream = [NSInputStream inputStreamWithFileAtPath:path];\n    [inputStream open];\n    \n    uint8_t buf[128];\n    \n    BOOL endOfFile = YES;\n    NSMutableData *buffer = [[NSMutableData alloc] init];\n    \n    while (endOfFile) {\n        memset(buf, 0x00, 128);\n        \n        NSInteger ret = [inputStream read:buf maxLength:128];\n        if (ret == 0 || ret == -1) {\n            endOfFile = NO;\n        }else {\n            NSData *adata = [[NSData alloc] initWithBytes:buf length:ret];\n            [buffer appendData:adata];\n        }\n    }\n    \n    if (buffer.bytes) {\n        NSLog(@\"读取文件成功\");\n        UIImage *image = [UIImage imageWithData:buffer];\n        \n        self.imageView.image = image;\n    }\n    \n    [inputStream close];\n}\n\n```\n### 使用nsfileHandle读取文件内容\n```objc\n- (void) readImageForFileHandle {\n    NSString *documentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];\n    \n    NSString *path = [documentPath stringByAppendingPathComponent:@\"慕课网/图片\"];\n    \n    NSFileHandle *handle = [NSFileHandle fileHandleForReadingAtPath:path];\n    \n    dispatch_queue_t queue = dispatch_queue_create(nil, DISPATCH_QUEUE_SERIAL);\n    dispatch_async(queue, ^{\n        NSData *data = [handle readDataOfLength:NSIntegerMax];\n        \n        if (data.length) {\n            NSLog(@\"读取文件成功\");\n            UIImage *image = [UIImage imageWithData:data];\n            \n            dispatch_sync(dispatch_get_main_queue(), ^{\n                self.imageView.image = image;\n            });\n        }\n    });\n    \n}\n\n```"
    }
  ]
}