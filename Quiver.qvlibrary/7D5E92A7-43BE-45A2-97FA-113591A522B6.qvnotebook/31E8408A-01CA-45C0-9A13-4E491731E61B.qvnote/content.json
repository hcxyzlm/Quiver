{
  "title": "算法",
  "cells": [
    {
      "type": "markdown",
      "data": "### 字符串翻转\n- 给定字符串“hello”，输出“olleh”\n```objc\n```\n\n### 链表反转\n- 头插法\n```objc\nListNode* ReverseList(ListNode* pHead) {\n\n    ListNode *pHeadNode, *pReversedHead, *pPriorNode;\n    pHeadNode = pHead;\n    pReversedHead = NULL;\n\n    while(pHeadNode != NULL){\n\n        ListNode *pNext = pHeadNode->next;\n        if (pNext == NULL) {\n            pReversedHead = pHeadNode;\n        }\n\n        pHeadNode->next = pPriorNode;\n\n        pPriorNode = pHeadNode;\n        pHeadNode = pNext;\n\n    }\n\n    return pReversedHead;\n}\n```\n\n### 有序数组合并\n- a = {1,4,6,7,9},b= {2,3,5,6,8,10}。meger= {1,2,3,4,5,6,6,7,8,9,10}\n\n### 有序链表合并算法\n```objc\nListNode* Merge(ListNode* pHead1, ListNode* pHead2)\n{\n    if (pHead1 == NULL) {\n        return pHead2;\n    }\n    if (pHead2 == NULL) {\n        return  pHead1;\n    }\n    ListNode *mergeHead = NULL;\n    ListNode *currentNode = NULL;\n    while (pHead1 != NULL && pHead2 != NULL) {\n        if (pHead1->val <= pHead2->val) {\n            if (mergeHead == NULL) {\n                mergeHead = currentNode = pHead1;\n            }else {\n                currentNode->next = pHead1;\n                currentNode = pHead1;\n            }\n            pHead1 = pHead1->next;\n        }else {\n            if (mergeHead == NULL) {\n                mergeHead = currentNode = pHead2;\n            }else {\n                currentNode->next = pHead2;\n                currentNode = pHead2;\n            }\n            pHead2 = pHead2->next;\n        }\n    }\n\n    if (pHead1 != NULL) {\n        currentNode->next = pHead1;\n    }\n    if (pHead2) {\n        currentNode->next = pHead2;\n    }\n\n    return mergeHead;\n}\n```\n\n### hash算法\n- 在一个字符串中找出第一个只出现一次的字符(比如: 输入abaccdeff,输出:b)\n- 数组中存储的是每个字符出现的次数\n![IMAGE](quiver-image-url/D9B24E73A0DE205BC175019835231E71.jpg =1334x750)\n![IMAGE](quiver-image-url/17570832868794C5359FB5FA238021B9.jpg =1334x750)\n\n### 查找两个子视图的共同父视图\n![IMAGE](quiver-image-url/5A02EDBF63FC7F31A714FA24E650B3EB.jpg =1334x750)\n```objc\n- (NSArray <UIView *> *)findCommonSuperView:(UIView *)viewOne otherView:(UIView *)otherView {\n    \n    // 查找第一个view所有的父视图\n    NSArray *firstSuperViews = [self superViewArrayWith:viewOne];\n    NSArray *otherSuperViews = [self superViewArrayWith:otherView];\n    \n    NSMutableArray *commonSuperViews = [[NSMutableArray alloc] init];\n    \n    NSInteger i = 0;\n    \n    // 数组倒叙遍历，找到view不相等的则终止循环，之前遍历过视图的就是共同父视图\n    while (i < MIN(firstSuperViews.count, otherSuperViews.count)) {\n        UIView *fistView = firstSuperViews[firstSuperViews.count - i -1];\n        UIView *secondView = otherSuperViews[otherSuperViews.count - i -1];\n        if (fistView == secondView) {\n            [commonSuperViews addObject:fistView];\n        }else {\n            break;\n        }\n        i++;\n    }\n    \n    return commonSuperViews;\n}\n\n// 查找view的父视图\n- (NSArray *)superViewArrayWith:(UIView *)view {\n    \n    UIView *tmp = view.superview;\n    NSMutableArray *array = [NSMutableArray array];\n    while (tmp != nil) {\n        [array addObject:tmp];\n    }\n    \n    return array;\n}\n```\n\n### 求无序数组当中的中位数(n为奇数，(n+1)2, n为偶数,(n/2 + (n/2+1))/2)\n- 排序算法+中位数(冒泡排序，快速排序，堆排序)\n- 利用快排思想(分治思想)\n- ![IMAGE](quiver-image-url/4CC32C8B3EEDC853CCABE2E6642E89EC.jpg =1334x750)\n- ![IMAGE](quiver-image-url/711AFFAA3CFBE1B5E20527F5A4D0E72B.jpg =1334x750)\n![IMAGE](quiver-image-url/913431B13ACB140FA728B5848CBBA32E.jpg =1334x750)"
    }
  ]
}