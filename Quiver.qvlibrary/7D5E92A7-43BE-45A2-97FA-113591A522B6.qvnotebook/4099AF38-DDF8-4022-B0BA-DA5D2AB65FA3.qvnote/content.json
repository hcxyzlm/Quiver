{
  "title": "多线程",
  "cells": [
    {
      "type": "markdown",
      "data": "ios 多线程\n1. gcd\n2. NSOperation(afn, sdimage)\n3. nsthread\n4. pthread(linux)\n\n### GCD\n\n### 死锁原因\n1.队列引起的循环等待\n\n### 示例\n```objc\n-(void)viewDidLoad {\n    [super viewDidLoad];\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@\"current pthread %@\", [NSThread currentThread]);\n    });\n    NSLog(@\"%s end\", __func__);\n}\n```\n\n### bat面试题\n![IMAGE](quiver-image-url/4F15EB7FB27FB91A0F9FC4AEAB351A00.jpg =1334x750)\n\n### 怎样利用gcd实现多读单写？(读是并发，读和写是互斥，写和写互斥)\n- 通过dispatch_barrie的技术实现\n- dispatch_barrie一般配合跟自定义并发队列，不能和系统并发任务配合\n\n```objec\n@interface LMdataCenter()\n\n@property (nonatomic, strong) NSMutableArray *dict; //共享数据\n\n@property (nonatomic, strong) dispatch_queue_t currentQueue; // 自定义队列\n\n@end\n\n@implementation LMdataCenter\n- (instancetype)init {\n    self = [super init];\n    _dict = [[NSMutableArray alloc] init];\n    _currentQueue = dispatch_queue_create(\"com.currentQueue.thread\", DISPATCH_QUEUE_CONCURRENT); //并发队列\n    return  self;\n}\n\n/*\n 读操作\n 因为读是在并发队列执行，所以可以实现并发,允许多个操作并发执行\n 因为要立即返回，所以不能异步。要使用dispatch_barrier_sync同步执行立即返回\n */\n- (id)objectForKey:(NSString *)string {\n    __block id object;\n    dispatch_barrier_sync(self.currentQueue, ^{\n        object = [self.dict valueForKey:string];\n    });\n    \n    return object;\n}\n\n// 当前队列如果遇到dispatch_barrier_async，会先将dispatch_barrier_async的前操作完成，再进行dispatch_barrier_async\n// 由于它是一个障碍 Block ，这个 Block 永远不会同时和其它 Block 一起在 concurrentPhotoQueue 中执行\n- (void)setValue:(id)object forkey:(NSString *)key {\n    \n    dispatch_barrier_async(self.currentQueue, ^{\n        [self.dict setValue:object forKey:key];\n    });\n}\n\n```\n\n![IMAGE](quiver-image-url/60668780BA6FB7A1D384BC767C76A612.jpg =1334x750)\n\n### 使用gcd实现这个需求: a,b,c三个任务并发，执行完后执行任务d\n- 使用dispatch_group_t线程组的技术实现\n\n### NSOperation相关面试问题\n-  需要和NSOperationQueue配合使用来配合使用多线程方案\n-  添加任务依赖\n-  任务执行状态控制\n-  最大并发量\n-  如果只重写main方法，底层控制变更任务执行完成状态，以及任务退出\n-  如果重写了start方法，自行控制任务状态\n-  源码基于gnusetp-base-1.24.9\n-  系统是怎样移除一个isFinished= yes的nsoperation?答案:通过kvo\n\n### NSThread相关面试\n- 启动流程，start-->创建pthread-->main()-->targetselect-->exit()\n- 内部实现机制如何实现？和如果通过runloop实现一个常驻内存？\n\n### ios当中都有哪些锁\n- @synchronized 一般在创建单例的对象使用\n- atomac 修饰关键字，对被修饰的对象进行原子操作(不负责使用 add,remove操作)\n- nsSpinlock自旋锁，循环等待访问，不释放当前资源，用于轻量级数据访问，简单的int值加减操作。引用计数会使用到\n- nslock，一般用来线程同步问题\n- NSRecursiveLock,循环锁,成对出现，用来循环加锁和重入\n- dispatch_semaphore_t信号量，阻塞是一个主动行为，唤醒是一个被动行为\n- 互斥锁，pthread_mutex_t\n\n### 面试题\n![IMAGE](quiver-image-url/692290176CF13305D2A4EA0E44D07568.jpg =1334x750)\n解决：\n![IMAGE](quiver-image-url/20CC804F4276BD588CF5CD3D62D18116.jpg =1334x750)\n\n\n"
    }
  ]
}