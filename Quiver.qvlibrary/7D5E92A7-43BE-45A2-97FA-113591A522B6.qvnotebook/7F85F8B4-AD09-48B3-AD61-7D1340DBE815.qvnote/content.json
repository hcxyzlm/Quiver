{
  "title": "object-c面试相干",
  "cells": [
    {
      "type": "markdown",
      "data": "## 分类\n\n### 分类作用\n  - 私有方法声明,在.m文件中\n  - 给现有的类添加方法\n  - 将一个类的实现拆分成多个独立的源文件  \n  ```objc\n  \n  @interface MethodDetailMusic : NSObject\n{\n    @public NSString *publicStr;\n}\n\n- (void)initPrivateString;\n\n@end\n  ```\n  \n### 分类的影响\n1. 分类可以为类添加方法\n2. 最好不要修改原有方法，会发生不可估的影响。会影响继承，比如你分类重写了父类的方法，在子类调用父类方法也是会调用到分类的重写方法\n\n### 注意点\n1. 有多个同名的分类方法名，最先访问最后的编译分类，所以最后遍历的分类会最终生效\n2. 并不会覆盖原有的系统访问，只是把分类的放在放在系统方法前面，所以每次查找方法会先找到分类方法\n\n### 源码解析\ndyld(加载二进制文件)-->\t_objc_init-->map_2_images-->map_images_nolock->(_read_images->addUnattachedCategoryForClass 把分类注册到宿主类)->remethodizeClass->\nattachCategories(添加分类)-->attachLists(拷贝原来的宿主类方法，把分类方法放在原来方法前面)\n\n### 总结：\n  - 分类添加的方法可以“覆盖”原类方法\n  - 同名分类方法谁能生效取决于编译顺序\n  \n  \n## 利用关联对象技术实现分类添加属性\n```objc\nvoid objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);// 设置关联对象\nid objc_getAssociatedObject(id object, const void *key);// 获取关联对象\n\nvoid objc_removeAssociatedObjects(id object);// 移除该类的所有关联对象\n```\n\n### 源码解析\n1. AssociationsManager来管理一个关联对象。内部有AssociationsHashMap的数据结构，来管理关联对象的key-value(object-->ObjectAssociationMap)-->\n2. ObjectAssociationMap-->(key-->value)--》ObjcAssociation（key, objc_AssociationPolicy）组成value\n\n\n### 扩展\n1. 一般用扩展来做什么？1.声明私有属性 2.声明私有方法  3. 声明私有成员变量\n2. 分类和扩展区别？ 扩展是编译时决议，只以声明的形式存在 2. 不能为系统类添加扩展\n\n### 代理\n1.准确来说是一个软件设计模式，代理模式\n2. ios 已protocol形式体现\n3. 传递方式是一对一，通知是多对一\n4. 一般声明为week已规避循环引用\n\n### 通知\n1.是使用观察者模式来实现的用于跨层传递消息的机制\n2.传递方式为一对多\n\n3. 通知的传递机制\n![IMAGE](quiver-image-url/F530FCC01D0AF16F6A1A837A229D8892.jpg =1334x750)\n\n4. 如何实现通知机制？\n![IMAGE](quiver-image-url/44159EEE7E7D52FB8DCC480ED43D7792.jpg =1334x750)\n5. 通知是发生在主线程还是子线程？ 跟发送通知的线程有关，跟发送通知的处于同一个线程\n\n### 面试题, 如果实现delegate一对多\n[传送门](https://github.com/alejandro-isaza/MultiDelegate)\n使用NSPointerArray来保存所有的delegate, 理由消息转发机制把消息转发到实现delegate的类上\n```oject-c\n- (BOOL)respondsToSelector:(SEL)selector {\n    if ([super respondsToSelector:selector])\n        return YES;\n\n    for (id delegate in _delegates) {\n        if (delegate && [delegate respondsToSelector:selector])\n            return YES;\n    }\n    \n    return NO;\n}\n\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector {\n    NSMethodSignature* signature = [super methodSignatureForSelector:selector];\n    if (signature)\n        return signature;\n    \n    [_delegates compact];\n    if (self.silentWhenEmpty && _delegates.count == 0) {\n        // return any method signature, it doesn't really matter\n        return [self methodSignatureForSelector:@selector(description)];\n    }\n\n    for (id delegate in _delegates) {\n        if (!delegate)\n            continue;\n\n        signature = [delegate methodSignatureForSelector:selector];\n        if (signature)\n            break;\n    }\n    \n    return signature;\n}\n\n- (void)forwardInvocation:(NSInvocation *)invocation {\n    SEL selector = [invocation selector];\n    BOOL responded = NO;\n    \n    NSArray *copiedDelegates = [_delegates copy];\n    for (id delegate in copiedDelegates) {\n        if (delegate && [delegate respondsToSelector:selector]) {\n            [invocation invokeWithTarget:delegate];\n            responded = YES;\n        }\n    }\n    \n    if (!responded && !self.silentWhenEmpty)\n        [self doesNotRecognizeSelector:selector];\n}\n\n```\n\n### kvo \n- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context;\n1. 通过kvc设置value是否可以生效？1. 能，kvc最终会调用stter方法\n2. 通过成员变量直接赋值value是否生效？1. [obj increse], // 不会\n3. 在stter方法实现willChangeValueForKey,可以手动实现kvo。\n\n### 总结\n1. 使用stter方法传值kvo才会生效\n2. 使用setValue:forkey 改值kvo才会生效\n3. 通过变量直接修改手动添加kvo才会生效\n4. 使用成员方法直接对_value赋值kvo不会生效\n\n\n### kvc相关问题\n1. settvalue:forkey为键值方法\n2. 这种机制会破坏面向对象的私有机制，可以直接设置私有变量的值\n3. 可以通过重写类的accessInstanceVariablesDirectly方法对kvc是否生效，该方法默认为yes.如果找不到会抛出异常，valueforUndefinekey。\n\n### 属性关键字\n1. assgin 和weak的区别？ assgin所指对象释放之后不会制nil, 产生野指针。weak在所指对象释放之后置为nil\n2. copy修饰NSMutableArray会有什么结果？ crash，copy生成一个不可变的nsarray，把不可变的数组赋值给可变数组会crash。\n\n###  weak 关键字的使用场景\n1. block里面解决循环应用\n2. NSTimer解决循环应用\n3. 单例，当这个单例没有对象所持有的时候，该单例就会被释放内存。弱引用单例\n\n### 深拷贝和浅拷贝区别\n1. 是否开辟了新的内存空间\n2. 是否影响了引用计数\n3. 可变对象的copy 和mutablecopy都是深拷贝\n4. 不可变对象的copy是浅拷贝，mutablecopy是深拷贝\n5. copy方法返回的都是不可变对象\n\n### 笔试题\n1. mrc下如何重写retain修饰变量的setter方法？\n```objc\n@property (nonatomic,retain) id objc;\n- (void)setObjc:(id)objc {\n    if (_objc != objc) {\n        [_objc release];\n        _objc = [objc retain];\n    }\n}\n\n```\n\n### NSDictory的底层实现\n1. 底层数据结构为hash table, 哈希表是根据键(key)而直接访问在内存中的数据结构\n2. 通过一定的算法得出key，如果得到key有冲突的话，可以通过拉链法来解决\n3. 哈希冲突：如果关键字k不同，但是通过哈希函数f(k)得到的结果是一样的，这样就会出现哈希冲突，也就是说，得到的这个地址有可能已经存在键值对了.大概的原理是将一个存储单位的所有元素保存在一个链表中\n4. 查找的时间复杂度为 O(1)\n\n### 自定义类作为NSDictory的key怎么实现？\n1. 遵循 NSCopying 协议\n2. 重载- (NSUInteger)hash;  - (BOOL)isEqual:(id)object;  方法\n3. "
    },
    {
      "type": "text",
      "data": "<br>"
    }
  ]
}