{
  "title": "runtime面试题",
  "cells": [
    {
      "type": "markdown",
      "data": "### runtime\n1. 类对象与元类对象\n2. 缓存方法查找\n3. 消息传递\n4. method-swizzling\n\n### 数据结构\n1. id ->objc_object{isa_t关于isa操作对象)\n2. Class-->objc_class-->objc_object\n\n```objc\nstruct objc_object{\n  Class superclass;\n  cache_t cache;\n  class_data_bits_t bits;\n}\n```\n\n### isa指针指向\n1，公用体 isa_t\n2.关于对象，其指向类对象\n3.关于类对象，指向元类对象。-->meta class\n\n### cache_t\n1. 缓存方法。用于快速查找方法执行函数\n2. 可以增量扩展的哈希表结构\n3. 是局部性原理的最佳应用\n4. 数组里面有bucket_t。\n\n\n### class_data_bits_t\n1. 主要是class_rw的封装\n2. class_rw代表了类相关的读写信息，对class_ro_t的封装。一个类可变的东西都可以动态修改， 比如方法列表\n3. class_ro_t类的相关只读信息，不可修改\n```objc\nstruct class_ro_t {\n    uint32_t flags;\n    uint32_t instanceStart;\n    uint32_t instanceSize;\n#ifdef __LP64__\n    uint32_t reserved;\n#endif\n\n    const uint8_t * ivarLayout;\n    \n    const char * name;\n    method_list_t * baseMethodList;\n    protocol_list_t * baseProtocols;\n    const ivar_list_t * ivars;\n\n    const uint8_t * weakIvarLayout;\n    property_list_t *baseProperties;\n\n    method_list_t *baseMethods() const {\n        return baseMethodList;\n    }\n};\n```\n\n### method_t\n1. 函数四要素 1. 名称 2 返回值 3 参数 4 函数体\n\n```objc\nstruct method_t {\n    SEL name;\n    const char *types;\n    IMP imp;\n```\n\ntype encodings\n- (void)amethod--> v@:, @相当于接受者，self==id, :-->SEL\n\n### 总结\n![IMAGE](quiver-image-url/15F078A5E28E23E88292C8038EF41F13.jpg =1334x750)\n\n\n### runtime使用场景\n1. hook method swizzle\n2. 分类\n3. 函数调用\n4. kvo(动态创建kvo子类)\n\n### 类，元类，元类对象\n1. 类对象存储实例方法列表等信息\n2. 元类对象存储类方法等信息\n3.元类对象，类的isa\n\n### 面试题\n21. 下面的代码输出什么？\n11\n@implementation Son : Father\n- (id)init\n{\n    self = [super init];\n    if (self) {\n        NSLog(@\"%@\", NSStringFromClass([self class]));\n        NSLog(@\"%@\", NSStringFromClass([super class]));\n    }\n    return self;\n}\n@end\n\n解答：\n我们用clang命令clang -rewrite-objc test.m\n1. 两个都是son，而在调用 [super class]时，会转化成 objc_msgSendSuper函数。看下函数定义:\n2. id objc_msgSendSuper(struct objc_super *super, SEL op, ...);\nobjc_super的结构体的定义为：\nstruct objc_super {\n    __unsafe_unretained _Nonnull id receiver;\n    __unsafe_unretained _Nonnull Class super_class;\n};\n\nreceiver这个参数为son self本身。所以最终调用father的class方法，当前类找不到，就会查找到nsobject的类，该类返回的接受者是son，所以返回的也是son这个类型\n而当调用 [super class]时，会转换成objc_msgSendSuper函数。第一步先构造 objc_super 结构体，结构体第一个成员就是 self 。 第二个成员是 (id)class_getSuperclass(objc_getClass(“Son”)) , 实际该函数输出结果为 Father。 第二步是去 Father这个类里去找 - (Class)class，没有，然后去NSObject类去找，找到了。最后内部是使用 objc_msgSend(objc_super->receiver, @selector(class))去调用， 此时已经和[self class]调用相同了，故上述输出结果仍然返回 Son\n\n### ![IMAGE](quiver-image-url/B5D42F24A2E1E8345A846ED955870FFD.jpg =980x412)\n1. 当调用-号方法时，则去查找class method。 当调用类方法时，则去meta class方法中查找。\n\n### 缓存查找\n1. 给定值是SEL,目标值的对应bucket_t的IMP。通过哈希查找找到对应的imp。\n2. f(k) = key & mask\n\n### 当前类查找\n1. 对于已排序好的列表，采用二分查找算法查找对应的执行函数\n2. 对于没有排序好的列表，采用一遍排序查找对应的执行函数。\n\n### 父类诸暨查找\ncusclass= cuclasss->superclass。\n\n### 查找流程源码解析\n```objc\nobjc_msgSenduncache-->_class_lookupMethodAndLoadCache3->lookUpImpOrForward->getMethodNoSuper_nolock\n```\n\n### objc_msgSend的不同版本\n1. 老版本objc_msgSend(receiver, selector, arg1, arg2, …)；\n2. 新版本objc_msgSend(), 不带参数的版本，会crash，可以使用objc_msgSendv_stret来防止crash\n\n### 消息转发流程\n1. 当一个对象调用方法最终会转化成objc_msgSend的方法，如果都找不到就进入消息转发机制。有三部可以处理\n2. 重写resolveInstanceMethod进入动态方法解析，如果返回yes.则消息转发结束，可以在这个方法动态添加一个实例方法。返回NO,则进入消息转发第二部\n3. 被援接受者转发机制，重写forwardingTargetForSelector方法，并返回一个可以转发的一个类，交给此类去处理。返回nil,则进入消息转发第三部\n4. 完整消息转发机制。methodSignatureForSelector，forwardInvocation。如果都不处理，则会抛出异常。\n\n\n### method-swizzling\n```objc\nvoid Swizzle(Class c, SEL origSEL, SEL newSEL)\n{\n    Method origMethod = class_getInstanceMethod(c, origSEL);\n    Method newMethod = nil;\n    if (!origMethod) {\n        origMethod = class_getClassMethod(c, origSEL);\n        if (!origMethod) {\n            return;\n        }\n        newMethod = class_getClassMethod(c, newSEL);\n        if (!newMethod) {\n            return;\n        }\n    }else{\n        newMethod = class_getInstanceMethod(c, newSEL);\n        if (!newMethod) {\n            return;\n        }\n    }\n    \n    //自身已经有了就添加不成功，直接交换即可\n    if(class_addMethod(c, origSEL, method_getImplementation(newMethod), method_getTypeEncoding(newMethod))){\n        class_replaceMethod(c, newSEL, method_getImplementation(origMethod), method_getTypeEncoding(origMethod));\n    }else{\n        method_exchangeImplementations(origMethod, newMethod);\n    }\n}\n```\n\n### 动态方法解析\n1. @dynamic\n2. 动态运行时语言将函数决议推迟到运行时\n3. 编译时语言在编译期进行函数决议\n\n### 实战\n1. [obj foo] 和 objc_msgsend()函数之间有什么关系\n2. runtime如果通过@select()找到对应的impe地址？\n3. 能否向编译后的类添加实例变量？不能\n4. 能否向动态添加类的添加实例变量？能，像在注册类对之前添加就可以。\n5. json 转model的原理? 使用class_copyPropertyList获取model的所有变量，查询出所有的属性，根据属性名查找json的字段，有就赋值。查找到使用kvc setvalue赋值给model。\n```objc\n@interface NSObject (Sark)\n+ (void)foo;\n@end\n\n@implementation NSObject (Sark)\n\n- (void)foo\n{\n    NSLog(@\"IMP: -[NSObject (Sark) foo]\");\n}\n\n[NSObject foo];\n[[NSObject new] foo];\n@end\n```\n会输出IMP: -[NSObject (Sark) foo]。\n\n```objc\n```\n解答:因为找不到元类沿着继承链找到nsobject, 找不到该方法，就会去他的父类找，nsobject->superclass指向实例变量。所以会在实例方法中能找到该方法。\n\n```objc\n@interface son:father\n\n+(void)test;\n\n@implementation son\n\n\n- (void)test {\n    NSLog(@\"implementation test method\");\n}\n\n@end\n\n[son test]\n```\n解答: 会crash掉。因为没找到test方法\n\n### 类的结构\n![IMAGE](quiver-image-url/021C0B44A9298289CED1AEF5D97703C9.jpg =494x223)\n![IMAGE](quiver-image-url/376F8F801F522CE2FFF43BDF055396FA.jpg =333x107)\n![IMAGE](quiver-image-url/54CC5800C8A38A930E18285588926B91.jpg =489x202)"
    }
  ]
}