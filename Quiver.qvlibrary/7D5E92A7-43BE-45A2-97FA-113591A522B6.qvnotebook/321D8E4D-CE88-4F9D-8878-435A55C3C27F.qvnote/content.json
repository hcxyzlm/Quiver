{
  "title": " OC&iOS 面试题",
  "cells": [
    {
      "type": "markdown",
      "data": "## Objective-C\n### 面试题： 一个 NSObject 对象 占多少内存\n系统分配了16字节给 NSObject对象(使用 malloc_size),但NSobject对象内部只使用了8字节的空间(64环境下)，使用class_getInstanceSize 获得。\n原理： oc 对象会编译一个名为 objc_objcet 的结构体，objc_objcet结构体只有一个成员变量 isa，他是一个 Class 类型。Class是一个名为 objc_class 的结构体指针。所以可以认为，NSObject 是一个只有成员的结构体。nsobject*则是指向 objc_class 的结构体指针(结构体的地址就是第一个成员的地址)\n```objc \n#import <objc/runtime.h> #import <malloc/malloc.h>\ntypedef struct objc_object NSObject; struct objc_object {\nClass _Nonnull isa OBJC_ISA_AVAILABILITY; };\ntypedef struct objc_class *Class;\nNSLog(@\"%zu\", class_getInstanceSize([NSObject class])); // 8 NSLog(@\"%zu\", malloc_size((__bridge const void*)obj)); // 16\n// class_getInstanceSize\nsize_t class_getInstanceSize(Class cls) {\nif (!cls) return 0;\nreturn cls->alignedInstanceSize(); }\n// Class's ivar size rounded up to a pointer-size boundary. uint32_t alignedInstanceSize() {\nreturn word_align(unalignedInstanceSize()); }\n// alloc 16 16 size_t instanceSize(size_t extraBytes) {\nsize_t size = alignedInstanceSize() + extraBytes; // CF requires all objects be at least 16 bytes. if (size < 16) size = 16;\nreturn size;\n}\n```\n\n面试题：下面的 Person 对象和 Struct 对象分别占用多少内存？\n```objc\n@interface Person : NSObject\n@property (nonatomic, assign) NSInteger age; @end\n@implementation Person \n@end\n@interface Student : Person\n@property (nonatomic, assign) NSInteger no;\n@end\n@implementation Student \n@end\n```\n\n上面的代码编译成 c++的结果是：\n\nstruct NSObject_IMPL { Class isa;\n};\nstruct Person_IMPL {\nstruct NSObject_IMPL NSObject_IVARS; // 8bytes NSInteger _age; // 4bytes\n}; // 16bytes\nstruct Student_IMPL {\nstruct Person_IMPL Person_IVARS; NSInteger _no;\n};\n\n所以 Person 和Student 的对象占用内存为16， 需要对齐16字节\n\n### oc 的对象有哪几种？\n- 实例对象\n- 类对象\n- 元类对象\n\n获取类对象\n```objc\nNSObject *obj1 = [[NSObject alloc] init]; \nClass objcClass1 = [obj1 class];\nClass objcClass2 = [NSObject class]; \nClass objcClass3 = object_getClass(obj1);\n```\n获取元类对象：\n//把类对象当做参数传入获取元类对象\nClass objectMetaClass = object_getClass([NSObject class]);\n\n### 面试题：\n对象的isa指针指向哪里？\n实例对象的 isa指向类对象\n类对象的 isa 指向元类对象\n元类对象的isa 指向基类的元类\n基类的 isa 指向自身\nisa 指针总结\n实例对象isa 指向类对象\n类对象的 isa 指向元类对象\n元类的对象 isa 指向基类(NSObject)的元类\n基类的(nsobject)的 isa 指向自身\n\nsuperclaass 指针总结\n类对象的superclass 指向父类的类对象\n如果没有父类，则superclaass为空\n元类对象的 superclass 指向父类的元类对象\n基类的(nsobject)的元类对象指向基类(nsobject)的类对象\n\n面试题： 下面的代码运行结果是什么？为什么？\n```objc\n@interface Person : NSObject + (void)test;\n@end\n@implementation Person @end\n@interface NSObject (Test) @end\n@implementation NSObject (Test) - (void)test {\nNSLog(@\"-[NSObject test]\"); }\n@end\n[Person test];s\n```\n\n运行的结果是\n[NSObject test]。因为调对象。用的是类方法，如果基类的元类对象没有找到该方法，则会通过基类的元类对象 superclass 指针去找基类的类对象。类对象找的就是实例方法\n\n## nil, NULL, Nil, NSNull的区别\nnil == (id)0指向一个对象的空指针\nNil == (Class)指向一个类的空指针\nNULL == (Void*)0指向其他类型，表示控制对象\nNSNull == (NSNull null)在集合对象中，表示空值的对象\n\n### 单例的写法\n```objc\n@interface Singleton : NSObject<NSCopying> \n@end\n@implementation Singleton static Singleton *shareSingleton = nil; \n+ (instancetype)shareSingleton { \nstatic dispatch_once_t onceToken; dispatch_once(&onceToken, ^{\n\nshareSingleton = [[super allocWithZone:NULL] init]; \n}); \nreturn shareSingleton; \n} + (instancetype)allocWithZone:(struct _NSZone *)zone {\n\nreturn [Singleton shareSingleton];\n} - (id)copyWithZone:(struct _NSZone *)zone {\n\nreturn [Singleton shareSingleton];\n} \n+ (id)mutableCopyWithZone:(struct _NSZone *)zone {\n\nreturn [Singleton shareSingleton];\n} \n// MRC ARC #if !__has_feature(objc_arc) - (NSUInteger)retainCount {\n\n以下为兼容\n\n，由于现在的⼯程绝⼤多数都是\n\nreturn MAXFLOAT; \n} - (oneway void)release {} \n- (instancetype)retain {\n\nreturn [Singleton shareSingleton]; \n} #endif\n@end\n```\n\n注意：\nallocWithZone\n\n和copyWithZone都要重写，否则在调⽤alloc和copy时，这两个⽅法的默认实现会把单例对象的内存拷⻉⼀ 份，从⽽造成单例在内存中不唯⼀。\n\n\n## kvo& kvc\n面试题：iOS是⽤什么⽅式实现对⼀个对象的KVO的？（KVO的本质是什么？）\n- 利用 runtime API动态生成一个子类（objc_allocateClassPair），并且让 Instance对象isa指向这个全新的子类。\n全称为：NSKVONotify_XXX（isa 混写）\n当你修改instance对象的属性时，NSSetXXXValueAndNotify函数。\n在这个方法会调用 willchangeforkey,父类原来的 setter, didchangeforkey\ndidchangeforkey中会调用observeValueForKeyPath:ofObject:change:context:\n\n\n面试题：如何手动触发 kvo\n[self.person1 willChangeValueForKey:@\" age\" ]; [self.person1 didChangeValueForKey:@\" age\" ];\n\n面试题：直接修改成员变量会触发KVO吗？ \n不会。KVO的本质是重写setter，直接修改成员变量不会触发setter⽅法。要触发需要⼿动调⽤ willChangeValueForKey 和\ndidChangeValueForKey。严格上讲，不能交重写，修改了修改了 setter方法的函数指针。\n\n 面试题：\n 通过KVC修改属性能不能触发KVO？ 可以触发KVO。即使只有⼀个成员变量，没有setter⽅法，KVC内部也会去⼿动触发KVO的，即调⽤ willChangeValueForKey 和didChangeValueForKey\n\n。如下代码也可以触发KVO：\n```objc\n@interface MJPerson : NSObject {\n@public int age; \n} @end\n\n@implementation MJPerson \n@end\n\nvoid test() { \nMJObserver *observer = [[MJObserver alloc] init]; \nMJPerson *person = [[MJPerson alloc] init];\n\n// KVO [person addObserver:observer forKeyPath:@\" age\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];\n\n//添加监听\nKVC age [person setValue:@10 forKey:@\" age\" ]; //\n\n//通过修改属性也可以触发KVO\n\n// KVO [person removeObserver:observer forKeyPath:@\" age\" ];\n\n// 移除监听\n\n}\n```\n\n面试题：\n如何KVO⼀个数组元素的变量？ 不要直接调⽤[_observeModel.array addObject:cartModel]，而是直接调用\n func mutableArrayValueForKey(_ key: String) -> NSMutableArray\n \n ## ⾯试题：KVC的 setValue:forKey: 的原理\n \n ### 面试题： http 中，使用了缓存，如何知道服务器资源发生了改变\n http 的 cache-Control 这个报文头，决定了客户端是否需要向服务器发送请求(max-age设定的时间)，设置了 max-age。只是表示一个合理的变化频度，但是请求的文件也没有发生变化，那么服务器告诉客户端，文件没变化。还是取缓存数据就好了。\n 这个策略使用了 eTag 和 last-motify 来校验。\n etag: 资源的唯一匹配标识信息\n last-motifyed: 资源的最后一次修改时间\n 浏览器第一次请求数据时，服务器将缓存的标识 etag 和数据一起返回给客户端，客户端将两者备份到缓存数据库中。\n 再请请求时，客户端将备份的缓存标识etag+last-motifyedS@@@SA>g es gsg发送给服务端，服务端根据缓存标识进行判断，判断成功后，返回304状态码，可以使用缓存\n \n ### main()函数执行前做了那些事？\n1. 解析plist。加载信息，例如闪屏；沙盒建立、权限检查\n2. 【Mach-O加载】：加载所有依赖的Mach-O文件（递归调用Mach-O加载的方法）；加载可执行文件（App 的.o 文件的集合）\n3. [加载动态链接库】：进行 rebase 指针调整和 bind 符号绑定；定位内部、外部指针引用，例如字符串、函数等\n4. 【Objc 运行时的初始处理】：包括 Objc 相关类的注册、category 注册、selector 唯一性检查等\n5. 【初始化】：执行 +load() 方法，执行声明为attribute((constructor))的C函数，C++静态对象加载\n\nMain()\nmain()函数之后\n\n从main()函数开始至 appDelegate的\ndidFinishLaunchingWithOptions结束，称为main()函数之后的部分。\n主要执行内容\n* 首屏初始化所需配置文件的读写操作；\n* 首屏列表大数据的读取；\n* 首屏渲染的大量计算等。\n\n### 场景:假如有一张非常大的图片，可能有500MB，也可能有1个G甚至更大。需要显示在我们的iOS设备，该怎样加载呢?\n直接读取图片，加载到UIImageView会直接闪退\n苹果的开发者早就考虑到这个，给开发者提供了CATiledLayer了。CATiledLayer 为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入。在多个线程中为每个小块同时调用 -drawLayer:inContext: 方法。这就避免了阻塞用户交互而且能够利用多核心新片来更快地绘制。只有一个小块的 CATiledLayer 是实现异步更新图片视图的简单方法\n将CATitleKayer添加到scrollerview，局部加载。\n注意：\n1.退出页面时需要移除_tileLayer对象\n2.就算x,y时需要考虑屏幕分辩率\n\n1.在真正的业务中，需要的肯定是网络图片。CATiledLayer可与SDWebImage结合使用，并发下载和图片缓存的问题不需要再考虑。同时结合RunLoop的优化特性，只在空闲时加载图片。以达到性能最优。\n\n### 哈希冲突怎么解决？\n在使用拉链法解决哈希冲突时，每个箱子其实是一个链表，属于同一个箱子的所有键值对都会排列在链表中。\n\n## 优化\n面试题： 弱网的优化\nhttps://www.jianshu.com/p/a470ab485e39\n\n### wcdb 的原理\n\n设计初衷：WCDB+ORM解决SQL字符串的代码冗余和难以被编译器进行语法检查而造成的错误和时间浪费。SQL字符串太容易被注入。\n对比： FMDB的SQL拼接、难以防止的SQL注入。coredata也是方便 orm，但是学习成本高，稳定性差，而是多线程不安全。\nrelam,上手成本低，但是入侵性比较强。\n性能： WCDB支持多线程读与读、读与写并发执行，写与写串行执行\n映射关系：将一个 objc 的类映射到数据库的表和索引\n将类的属性，映射到数据库的字段\n缺点：所以引用WCDB的头文件，都要变成.mm 文件。因为是基于 objc c++，\n解决办法：使用分类来隔离。自己将 wcdb 封装了一层，实现隔离\n怎么映射：WINQ,基于 c++实现。将自然查询的sql集成到wcdb框架中的技术\n以免去拼接 sql字符串\n\n\n### OC\n__weak 和 __strong 的关系\n__weak 修饰的对象，不会影响对象的释放，当对象没有引用时，会自动将对象的指针至为 nil.\n__strong 修饰对象，为了确定 block用到的对象，不会被释放。出了代码快，引用计数器-1\n\n"
    }
  ]
}