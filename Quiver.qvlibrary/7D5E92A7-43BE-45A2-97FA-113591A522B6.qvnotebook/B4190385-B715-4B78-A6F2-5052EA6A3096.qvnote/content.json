{
  "title": "内存管理面试",
  "cells": [
    {
      "type": "markdown",
      "data": "\n### nsobject 的结构解析\n![IMAGE](quiver-image-url/47B3665A2DB2DA88EE3B58632BC9FE7E.jpg =679x345)\n![IMAGE](quiver-image-url/B0D4F3F017E304B6E6FDB5C3A54F2E70.jpg =474x385)\n可见isa是一个union是一个结构体。isa_t,cls,bits,还有一个结构体是公共一个内存。而 isa 总共会占据 64 位的内存空间（决定于其中的结构体）\n分配内存的结构体\n```objc\nstruct {\n        uintptr_t nonpointer        : 1;   // 是否是isa的指针类型。表示当前 isa 不是指针，但是其中也有 cls 的信息，类的指针都是保存在 shiftc\n        uintptr_t has_assoc         : 1;   // 是否有关联对象\n        uintptr_t has_cxx_dtor      : 1;   // 对象有 C++ 或者 ObjC 的析构器(destructor)，如果没有析构器就会快速释放内存\n        uintptr_t shiftcls          : 44; // 保存类的指针\n        uintptr_t magic             : 6;  // 用于调试器判断当前对象是真的对象还是没有初始化的空间\n        uintptr_t weakly_referenced : 1;  // 是否有弱引用表\n        uintptr_t deallocating      : 1;  // 对象正在释放内存\n        uintptr_t has_sidetable_rc  : 1;  // 对象的引用计数太大了，存不下\n        uintptr_t extra_rc          : 8;  // 对象的引用计数超过 1，会存在这个这个里面，如果引用计数为 10，extra_rc 的值就为 9\n    };\n```\n\n### 内存管理方法\n1. taggedpointer，小对象，nsnumber。\n2. NONPOINtER_ISA, 一个指针对剩余的比特位存储一些相关内容\n3. 散列表，包含弱引用表和引用计数表。\n\n### Tagged Pointer对象(64位下的Tagged pointer的对象)\n1. 在64位系统中，苹果对于像nsnumber 和nsdata的对象，改成了taggedpointer来存储。taggedpointer是一个假的指针，他指针不再是对象的地址，而是对应变量的值。\n2. 特点: 1.Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate 2.存储一个变量的值，他的指向也没有isa指针，所以不算一个对象，也没有分配在堆区。\n3. 内存读取上有着3倍的效率\n\n### NONPOINtER_ISA\n1. 一个类存储一ke个指针也存储内容。\n\n### 散列表方式\n1. sidetable 的结构{spinlock_t, 引用计数表，weak_table(弱引用表)}\n2. 使用多个表，分成8*n个表，采用分离锁来操作多个表。\n3. 怎么实现快速分流？sidetable的本质是一张hash表。key(对象指针)-->哈希函数-->sidetable。\n4. 哈希\n\n### 为什么不一个sideTable？\n1. 更好更快的查找内存\n\n### sidetable的数据结构\n```objc\nstruct SideTable {\n    spinlock_t slock;         // 自旋锁\n    RefcountMap refcnts;      // 引用技术表\n    weak_table_t weak_table;  // 弱引用表\n\n    SideTable() {\n        memset(&weak_table, 0, sizeof(weak_table));\n    }\n\n```\n\n### 数据结构\n1.spinlock_t ,忙等的锁。不会睡眠线程，一直会等待。适合于轻量访问。\n2. refcountMap，引用计数表。提高查找效率 ptr-->size_t。 size_t\n3. weak_table弱引用表，哈希表。\n```objc\nstruct weak_table_t {\n    weak_entry_t *weak_entries;   // weakptr<1>。对象的内存地址\n    size_t    num_entries;        //\n    uintptr_t mask;\n    uintptr_t max_hash_displacement;\n};\n```\n\n### arc & mrc\n1. mrc 手动引用计数。alloc retain release retainount autolelease dealloc\n2. arc 自动引用计数。是llvm和runtiem的协作结果，禁止调用retain release retainount autolelease dealloc， 新增weak,strong的属性关键字\n\n\n### alloc\n1. 经过一系列调用，最终调用了c函数的calloc\n2. 此时并没有设置引用计数为1， 调用retaincount会将计数器加1\n\n### retain\nSideTable& table = SideTables()[this];\nsize_t & refcountStorage = table.refcnts[this];\nrefcountStorage += SIDE_TABLE_RC_ONE\n\n### release 的实现原理\nSideTable& table = SideTables()[this];\nRefcountMap::iterator it = table.refcnts.find(this);\nit->second -= SIDE_TABLE_RC_ONE\n\n### retaincount\nSideTable& table = SideTables()[this];\n\n    RefcountMap::iterator it = table.refcnts.find(this);\n    size_t refcnt_result = 1;\n    refcnt_result += it->second >> SIDE_TABLE_RC_SHIFT;\n\n### dealloc 实现(重要)\n流程\n![IMAGE](quiver-image-url/85BE10E054352E5C96A9330C2F9E63FC.jpg =1334x750)\n\n### object_dispose实现\n开始-->objc_destructInstance() -->free(obj);\n\n### objc_destructInstance实现\n![IMAGE](quiver-image-url/8FE729C4EF70EF7820ED39E9360BB239.jpg =1334x750)\n\n### clearDeallocating实现\n![IMAGE](quiver-image-url/E6D8E0785F5786CBC8EAF2BFEC988BB7.jpg =1334x750)\n\nsidetable_clearDeallocating-->weak_clear_no_lock(清空弱引用表)-->table.refcnts.erase(it)(擦除引用计数)\n\n\n## 弱引用计数相关\n1. id __weak obj1 = obj-->objc_initWeak(&obj1, obj)\n\n### 添加weak变量\n![IMAGE](quiver-image-url/45D86196D325FE6D51A0858D72DF3857.jpg =1334x750)\n\n### 源码分析\n\nobjc_initWeak-->storeWeak-->weak_register_no_lock-->append_referrer(entry, referrer);\n\n1. 先通过哈希查找出该对类弱引用表。如果能找到弱引用表，则会把改对应的地址作为key, __weak变量指向作为value值。存储到哈希表中。\n\n\n### 清除weak变量，同时设置指向为nil。\n1. weak_clear_no_lock\n2. 等对象释放内存时，根据对象的指针找出弱引用表对应的weak_entry_t数组。遍历weak_entry_t数组把改对象的对应的指针置为nil。\n\n### 自动释放池\n1. autoreleasepool的实现原理？\n2. autoreleasepool嵌套使用？\n\n### 总结 \n当每次runloop将要结束的时候调用objc_autoreleasePoolPop。\n多层嵌套调用就是多次插入肖兵对象\n在for循环中alloc图片数据等内存消耗较大的场景手动插入autoreleasepool\n\n@autoreleasepool{}经过编译器会生成这样的代码\nvoid *ctx = objc_autoreleasePoolPush();\nobjc_autoreleasePoolPop(ctx);\n\n\n### objc_autoreleasePoolPush实现\nAutoreleasePoolPage::push()-->\n\n\n### objc_autoreleasePoolPop实现原理\n1.objc_autoreleasePoolPop-->一次pop的操作实际上等于一次批量的pop操作-->添加改page的中所有对象都会执行一次release的操作\n2. 根据传入的肖兵对象找到对应的栈，从next出一直出栈，直到找到传入的肖兵地址则结束。把中间的对象都执行release操作\n3. 回退next指针到正确的位置\n\n### 数据结构\n1. 是以栈为结点的通过双线链表的形式组合而成\n2. 和线程一一对应\n3. 先进后出，所有最近添加到autoreleasepool的先释放\n\n### AutoreleasePoolPage数据结构\nAutoreleasePoolPage {\n    id *next;           // 指向下一个栈可填充的位置\n    pthread_t const thread;\n    AutoreleasePoolPage * const parent;  // 父结点\n    AutoreleasePoolPage *child;          // 子结点\n    }\n    ![IMAGE](quiver-image-url/C10EB050005FBDF5954E8323B64EB51E.jpg =1334x750)\n    ![IMAGE](quiver-image-url/C10EB050005FBDF5954E8323B64EB51E.jpg =1334x750)\n    \n    由此可见，每次push一个AutoreleasePoolPage，先把nil的肖兵对象压栈,肖兵对象为POOL_BOUNDARY\n    \n    \n### [obj autorelease]\n    ![IMAGE](quiver-image-url/E6658B296AA643E5C09DFF52FF4002AE.jpg =1334x750)\n    \n### 源码\n```objc\n\n// 压栈操作，stop为肖兵对象的指针\nvoid releaseUntil(id *stop) \n    {\n        while (this->next != stop) {  // 找到栈顶的位置\n            \n            AutoreleasePoolPage *page = hotPage();\n\n            while (page->empty()) {\n                page = page->parent;\n                setHotPage(page);\n            }\n\n            page->unprotect();\n            id obj = *--page->next;\n            // 格式化next\n            memset((void*)page->next, SCRIBBLE, sizeof(*page->next));\n            page->protect();\n\n            if (obj != POOL_BOUNDARY) {  // 如果不等于肖兵，则为添加到pool中的对象，每个对象调用release方法。\n                objc_release(obj);\n            }\n        }\n\n        setHotPage(this);\n\n#if DEBUG\n        // we expect any children to be completely empty\n        for (AutoreleasePoolPage *page = child; page; page = page->child) {\n            assert(page->empty());\n        }\n#endif\n    }\n```\n\n## 循环引用\n1. 自循环应用\n2. 相互循环引用\n3. 多循环引用\n\n### 考点\n1.代理\n2.block\n3.nstimer\n4.大环引用\n\n### 如何破除循环引用\n1.避免产生循环引用，使用weak等关键字\n2.在合适的时机手动断环，把对象置为nil。\n\n### 具体方法\n1.__weak 断环\n2.__block，产生在block方面，注意：在mrc下，__blcok修饰对象不会增加引用计数，避免了循环引用。在arc,__block对象会被强引用，无法避免循环引用，手动解环。\n3.__unsafe_unretained，修饰对象不会增加引用计数，避免了循环引用。\n\n### nstime循环引用计数\n![IMAGE](quiver-image-url/5D472F06DD799F981F6EF6CFAA2D14A5.jpg =667x375)\n添加中间对象\n![IMAGE](quiver-image-url/08E696D1174199DE16FBD7F4DB02BCD8.jpg =551x139)\n\n## 总结\n  - 什么是arc\n  - 为什么weak指针指向的对象在废弃之后会被自动置为nil\n  \n  \n\n\n\n\n\n"
    }
  ]
}