{
  "title": "ui视图相关面试",
  "cells": [
    {
      "type": "markdown",
      "data": "#### UITableView\n  - 重用机制原理和运用， 卡顿&掉帧\n  - 事件传递和视图响应， 绘制原理&异步绘制\n  \n  \n### uitabiew\n1. 字母索引条\n2. 数据源同步问题，1.并发访问，数据拷贝。主线程拷贝一份数据，子线程进行网络请求。UI删除数据，记录删除操作。子线程数据返回，同步删除操作，把删除掉的数据剔除，再重新绘制，对内存的开销会有一定的影响  2. 串行访问，主线程删除操作在串行队列。删除操作会有一定的延迟\n  \n\n### UIView 和 CALayer的关系\n1. UIView为其提供内容，以及负责处理触摸等事件，基于响应链，响应事件。\n2. UILayer负责绘制，显示内容Contents\n3. 单一原则的设计模式，分工不同\n\n### 事件传递与视图响应链\n```objc\n- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event; // 决定找到那个合适响应该事件的视图\n- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event; // 事件是否在他的视图范围内\n````\n- 事件传递流程，自定向上传递\n点击屏幕->uiapplication-->uiwindow-->hitTest->pointInside-->subviews(倒叙方式遍历，最后添加view先遍历)-->找到视图-->结束\n\n![IMAGE](quiver-image-url/F185A40F2DE50A4C3C4768D7EC6C8487.jpg =1334x750)\n![IMAGE](quiver-image-url/5FA3665F9D1274B9B9F02BCD987E62C4.jpg =1334x750)\n- 视图事件响应流程,决定那个视图来响应事件，又上到下响应\n--> button-->viewD-->viewcontroller-->Window->uiapplication(最后没有找到，会忽略掉这个事件)\n```objc\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event;\n- (void)touchesMoved:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event;\n- (void)touchesEnded:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event;\n\n```\n![IMAGE](quiver-image-url/FFCD867FDC9E4CF8DD507B8F9A514097.jpg =1334x750)\n\n### 图像显示原理\n1. ![IMAGE](quiver-image-url/6177ECF6542DEE90E584CE364C3BDF77.jpg =1334x750)\n2. ![IMAGE](quiver-image-url/4ABF9DF6B56292F814C7E374AFA26949.jpg =1334x750)\n3. ![IMAGE](quiver-image-url/B9F81AC2B06CB1922FB631DBF0671521.jpg =1334x736)\n4. ![IMAGE](quiver-image-url/C48065590A74FD7E4BBDC0FA181D8010.jpg =1334x750)\n\n\n### UI卡顿相关\n- ui布局，文本绘制，图片解码的时间比较长\n  - 在16.7ms之间，在下一帧vsync(v信号)到达之前，cpu并没有完成下一帧的画面的合成\n  滑动优化方案：1. cpu 对象创建，调增，销毁放到子线程，预排班(布局计算，文本计算)，预渲染(文本异步绘制，图片解码)\n                2. gpu:纹理渲染，避免离屏渲染，视图混合\n                \n\n### UI绘制原理\n图片\n![IMAGE](quiver-image-url/C94000AA057599A06D83DF5E6CF1AC7F.jpg =1334x750)\n![IMAGE](quiver-image-url/4FE32E2A3F9EC0EA296E4ABCB5101FBE.jpg =1334x750)\n![IMAGE](quiver-image-url/A3AE4F55ED376FD36DE81F8EFA503258.jpg =1334x750)\n![IMAGE](quiver-image-url/B384D58BDCB3D07725A2B8AFDAF92A2F.jpg =1334x750)\n\n绘制流程：\n1. 手动调用setNeedsDisplay(标记这个视图为脏，需要绘制，然后在一次runloop结束进行绘制)-->uiview.layer.setNeedsDisplay方法-->[calayer display]-->是否clayer.detelegate 是否实现displayLayer方法。如果不实现就走系统绘制，代理绘制。绘制都是发生在子线程中的\n系统绘制->drawLayer:inContext: ->得到位图\n代理绘制-->drawLayer:inContext->drawRect()->(子线程)->得到bitmap位图进行绘制\n\n\n### 离屏渲染\n1.在屏渲染，指的是gpu的渲染操作是在当前用于显示的屏幕缓存区中进行的，更多是发生在gpu层面上\n2. 离屏渲染，指的是gpu在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作\n当我们指定了ui视图某些属性，如果在一个 VSync 时间内,没有完成位图内容的提交，那一帧就会被丢弃掉，等待下一次机会再展示，而这时显示屏会保留之前的内容不变，这就是卡顿的原因。\n何时触发？1.圆角(masksToBounds一起使用时) 2. 视图蒙版 3.阴影 4.光栅化\n为何要避免？会导致ui的卡顿和掉帧，会创建新的渲染缓冲区，内存上的开销。上下文切换\n\n### 保证uitableView滚动流畅的解决方案\n1.对象创建，调整，销毁\n2.布局计算，文本渲染(coretext),图片的解码,图像的绘制(在ondrawrect中操作提高性能)\n\n\n\n"
    }
  ]
}